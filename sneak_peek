This is essentially a placeholder for the next release note ...

o New optimization: request aggregation
  The original design of nonblocking I/O is to concatenate the fileviews of
  individual nonblocking requests and serve them with a single MPI-IO call,
  if possible. However, because MPI-IO requires the file displacements of
  the flattened fileview be in an monotonically nondecreasing order, the
  original approach (in v1.3.1 and prior) divides the nonblocking requests
  into groups such that each group abides by this MPI-IO fileview requirement.
  Each group is then carried out by a separate MPI-IO call. Performance can
  be poor if there are multiple groups and each group's aggregate access
  region is non-contiguous in the file.

  This revision fixes this problem by 1) sorting the starting offset of all
  nonblocking requests into a non-decreasing order; 2) dividing the requests
  into groups (two types of groups are identified: interleaving and
  non-interleaving); 3) for each non-interleaving group, concatenating
  fileviews of all requests in the group; 4) for each interleaving group,
  flattening fileviews of all requests in the group, merging the offset-length
  pairs, and concatenating them into a new integrated fileview; 5)
  concatenating the fileviews of all groups into a single one; 6) the final
  combined fileview is used by a single MPI-IO call to carry out the requests.
  Performance is expected to be improved as the number of MPI-IO calls is
  reduced to one.

  However, be warned about the additional memory requirement. The additional
  memory needed for flatterning the fileviews might be more than the I/O data
  itself. For example, a request to accessing a single column of a 2D integer
  array will result in offset-length pairs, each representing only a 4-byte
  integer where the C struct in PnetCDF for storing an offset-length pair
  takes 3*sizeof(MPI_Offset)=24 bytes (offset, length, and I/O buffer pointer).

o New APIs
  * get/put_varn_<type> for reading/writing a list of subrequests (each is
    specified by starts[i][ndims] and counts[i][ndims] for subrequest i.
    ndims is the number of dimension of the variable) to a single variable.
  * multiple put/get requests with explict buffer type names:
    ncmpi_mput_var_type(), ncmpi_mput_var1_type(), ncmpi_mput_vara_type(),
    ncmpi_mput_vars_type(), ncmpi_mput_varm_type(). Similar for get APIs.
    "type" is one of the followings: text, schar, uchar, short, ushort, int,
    uint, long, float, double, longlong, or ulonglong.
  * ncmpi_inq_nreqs() reports the number of pending nonblocking requests
  * ncmpi_inq_header_size() reports the size of the file header
  * ncmpi_inq_header_extent() reports the space currently allocated for the
    file header, (also the file offset of the first variable)
  * ncmpi_inq_put_size() reports the write amount committed by far
  * ncmpi_inq_get_size() reports the read amount committed by far
  * ncmpi_sync_numrecs() a collective API that can be called in independent
    data mode to synchronize the number of records in memory across all
    processes, and update to the file if NC_SHARE is set.

o New PnetCDF hint
  * nc_header_read_chunk_size: PnetCDF reads the file headers in chunks. This
    hint indicates the chunk size (in bytes). The default is 256 KB.

o New error code
  * NC_EINTOVERFLOW reports the error of 4-byte integer overflow. This usually
    happens due to MPI-IO data type constructor APIs' arguments using 4-byte
    integers.

o New environment variable
  * PNETCDF_SAFE_MODE environment variable can be used to enable/disable the
    internal checking for data/argument consistency across all processes (by
    calling collective MPI_Allreduce). Set it to 1 to enable the checking.
    Default is 0, i.e. disabled.

o New example programs
  * nonblocking_writef.f90 is the Fortran version of nonblocking_write.c
  * put_varn_float.c for using the new APIs ncmpi_put_varn_float_all()
  * put_varn_int.c and put_varn_intf.f90, for using the new APIs
    ncmpi_put_varn_int_all() and nfmpi_put_varn_int_all()
  * hints.c, for using PnetCDF hints
  * flex_c.c and flex_f.f90, for using blocking and nonblocking flexible APIs
  * mput.c, for using ncmpi_mput_vara_all() to write a series of arbitrary
    start[] and count[]
  * block_cyclic.c, for a *-block-cyclic 2D partitioning pattern
  * column_wise.c, for a *-cyclic 2D partitioning pattern
  * put_vara.f90 for using for nfmpi_put_vara_int_all()

o New programs for I/O benchmarks
  * benchmarks/aggregation.c -- evaluate PnetCDF's performance on I/O
    aggregation across multiple requests with different data access patterns.
  * benchmarks/write_block_read_column.c -- writes variables and reads back
    using different data partitioning patterns

o New test program
  * testcases/alignment_test.c -- test for header and fixed variable file
    offset alignments when entering redef mode

o Updates:
  * Files configure.in and all Makefile.in have been revised to detect MPI
    compilers automatically.
  * A new configure option to disable calling file sync. This is to be used
    when the underlying file system provides data consistency control.
  * add build recipe README.bgq for BGQ (e.g. Vesta/Mira/Cetus @ANL)
  * add build recipe README.CRAY-XE6 (e.g. Hopper @NERSC)
  * add declaration of flexible APIs for Fortran90
  * "make testing" now hides most of the stdout. Use "make verbose_testing" for
    verbose output.
  * add the command-line option "-k" to ncmpidum that reports the kind of
    netCDF file, similar to ncdump of netCDF4.

o Bug fixes
  * For collective APIs, many places have been changed to prevent program
    from hanging if a subset of the processes got errors. The fix will allow
    all processes participating the MPI collective calls in the PnetCDF, even
    if errors are detected on a subset of processes.
  * set the nonblocking request ID to NULL when the request length is zero
  * report error when bogus request IDs are passed in ncmpi_wait
  * when entering redef with different alignment hints, fixed-sized variables'
    file starting offsets should only be changed when it is bigger than the
    old ones
  * Fix some Fortran API intent in/out argument declarations

