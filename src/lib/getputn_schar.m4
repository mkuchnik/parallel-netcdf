dnl Process this m4 file to produce 'C' language file.
dnl
dnl If you see this line, you can ignore the next one.
/* Do not edit this file. It is produced from the corresponding .m4 source */
dnl
/*
 *  Copyright (C) 2003, Northwestern University and Argonne National Laboratory
 *  See COPYRIGHT notice in top-level directory.
 */
/* $Id$ */

#if HAVE_CONFIG_H
# include <ncconfig.h>
#endif

#include "nc.h"
#include "ncx.h"

/* ftype is the variable's nc_type defined in file, eg. int64
 * btype is the I/O buffer's C data type, eg. long long
 * buftype is I/O bufer's MPI data type, eg. MPI_UNSIGNED_LONG_LONG
 * apitype is data type appeared in the API names, eg. ncmpi_get_vara_longlong
 */

/*---- schar ----------------------------------------------------------------*/

/*----< ncmpix_getn_schar_schar() >------------------------------------------*/
int
ncmpix_getn_schar_schar(const void **xpp, MPI_Offset nelems, schar *tp)
{
    memcpy(tp, *xpp, nelems);
    *xpp = (void *)((char *)(*xpp) + nelems);
    return NC_NOERR;
}

dnl
dnl GETN_SCHAR(xpp, nelems, tp)
dnl
define(`GETN_SCHAR',dnl
`dnl
/*----< ncmpix_getn_schar_$1() >----------------------------------------------*/
int
ncmpix_getn_schar_$1(const void **xpp, MPI_Offset nelems, $1 *tp)
{
    /* file type (variable defined in file) is schar, buffer type is $1 */
    int    status = NC_NOERR;
    schar *xp = (schar *) *xpp;

    /* there is no ENDIANness issue, as schar is 1 byte */
    while (nelems-- != 0) {
        $2
        *tp++ = *xp++;
    }
    *xpp = (void *)xp;

    return status;
}
')dnl

GETN_SCHAR(uchar,  if (*xp < 0) status = NC_ERANGE;)
GETN_SCHAR(ushort, if (*xp < 0) status = NC_ERANGE;)
GETN_SCHAR(uint,   if (*xp < 0) status = NC_ERANGE;)
GETN_SCHAR(uint64, if (*xp < 0) status = NC_ERANGE;)

GETN_SCHAR(short)
GETN_SCHAR(int)
GETN_SCHAR(long)
GETN_SCHAR(float)
GETN_SCHAR(double)
GETN_SCHAR(int64)


/*----< ncmpix_pad_getn_schar_schar() >--------------------------------------*/
int
ncmpix_pad_getn_schar_schar(const void **xpp, MPI_Offset nelems, schar *tp)
{
    /* get n elements of schar from the variable defined as schar (NC_BYTE,
     * or NC_CHAR) in the file */
    MPI_Offset rndup = nelems % X_ALIGN;
    if (rndup) rndup = X_ALIGN - rndup;

    memcpy(tp, *xpp, nelems);
    *xpp = (void *)((char *)(*xpp) + nelems + rndup);

    return NC_NOERR;
}

dnl
dnl PAD_GETN_SCHAR(xpp, nelems, tp)
dnl
define(`PAD_GETN_SCHAR',dnl
`dnl
/*----< ncmpix_pad_getn_schar_$1() >------------------------------------------*/
int
ncmpix_pad_getn_schar_$1(const void **xpp, MPI_Offset nelems, $1 *tp)
{
    /* get n elements of "$1" from the variable defined as schar (NC_BYTE,
     * or NC_CHAR) in the file */
    int    status = NC_NOERR;
    schar *xp = (schar *) *xpp;

    MPI_Offset rndup = nelems % X_ALIGN;
    if (rndup) rndup = X_ALIGN - rndup;

    /* there is no ENDIANness issue, as schar is 1 byte */
    while (nelems-- != 0) {
        $2         /* check if can fit into $1 */
        *tp++ = *xp++;
    }
    *xpp = (void *)(xp + rndup);

    return status;
}
')dnl

PAD_GETN_SCHAR(uchar,  if (*xp < 0) status = NC_ERANGE;)
PAD_GETN_SCHAR(ushort, if (*xp < 0) status = NC_ERANGE;)
PAD_GETN_SCHAR(uint,   if (*xp < 0) status = NC_ERANGE;)
PAD_GETN_SCHAR(uint64, if (*xp < 0) status = NC_ERANGE;)

PAD_GETN_SCHAR(short)
PAD_GETN_SCHAR(int)
PAD_GETN_SCHAR(long)
PAD_GETN_SCHAR(float)
PAD_GETN_SCHAR(double)
PAD_GETN_SCHAR(int64)

int
/*----< ncmpix_putn_schar_schar() >------------------------------------------*/
ncmpix_putn_schar_schar(void **xpp, MPI_Offset nelems, const schar *tp)
{
    memcpy(*xpp, tp, nelems);
    *xpp = (void *)((char *)(*xpp) + nelems);

    return NC_NOERR;
}

/*----< ncmpix_pad_putn_schar_schar() >--------------------------------------*/
int
ncmpix_pad_putn_schar_schar(void **xpp, MPI_Offset nelems, const schar *tp)
{
    MPI_Offset rndup = nelems % X_ALIGN;
    if (rndup) rndup = X_ALIGN - rndup;

    memcpy(*xpp, tp, nelems);
    *xpp = (void *)((char *)(*xpp) + nelems);

    if (rndup) {
        memcpy(*xpp, nada, rndup);
        *xpp = (void *)((char *)(*xpp) + rndup);
    }

    return NC_NOERR;
}


dnl
dnl PUTN_SCHAR(xpp, nelems, tp)
dnl
define(`PUTN_SCHAR',dnl
`dnl
/*----< ncmpix_putn_schar_$1() >----------------------------------------------*/
int
ncmpix_putn_schar_$1(void **xpp, MPI_Offset nelems, const $1 *tp)
{
    /* put n elements of data in $1 to file type schar */
    int status=NC_NOERR;
    schar *xp = (schar *) *xpp;

    while (nelems-- != 0) {
        $2         /* check if can fit into schar */
        *xp++ = (schar) *tp++;
    }
    *xpp = (void *)xp;

    return status;
}
')dnl

PUTN_SCHAR(uchar,  if (*tp > X_SCHAR_MAX) status = NC_ERANGE;)
PUTN_SCHAR(ushort, if (*tp > X_SCHAR_MAX) status = NC_ERANGE;)
PUTN_SCHAR(uint,   if (*tp > X_SCHAR_MAX) status = NC_ERANGE;)
PUTN_SCHAR(uint64, if (*tp > X_SCHAR_MAX) status = NC_ERANGE;)

PUTN_SCHAR(short,  if (*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN) status = NC_ERANGE;)
PUTN_SCHAR(int,    if (*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN) status = NC_ERANGE;)
PUTN_SCHAR(long,   if (*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN) status = NC_ERANGE;)
PUTN_SCHAR(float,  if (*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN) status = NC_ERANGE;)
PUTN_SCHAR(double, if (*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN) status = NC_ERANGE;)
PUTN_SCHAR(int64,  if (*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN) status = NC_ERANGE;)


dnl
dnl PAD_PUTN_SCHAR(xpp, nelems, tp)
dnl
define(`PAD_PUTN_SCHAR',dnl
`dnl
/*----< ncmpix_pad_putn_schar_$1() >------------------------------------------*/
int
ncmpix_pad_putn_schar_$1(void **xpp, MPI_Offset nelems, const $1 *tp)
{
    /* put n elements of $1 data type to the variable defined as schar
       in the file */
    int status=NC_NOERR;
    schar *xp = (schar *) *xpp;

    MPI_Offset rndup = nelems % X_ALIGN;
    if (rndup) rndup = X_ALIGN - rndup;

    while (nelems-- != 0) {
        $2             /* check if can fit into schar */
        *xp++ = (schar) *tp++;
    }

    if (rndup) {
        memcpy(xp, nada, rndup);
        xp += rndup;
    }
    *xpp = (void *)xp;

    return status;
}
')dnl

PAD_PUTN_SCHAR(uchar,  if (*tp > X_SCHAR_MAX) status = NC_ERANGE;)
PAD_PUTN_SCHAR(ushort, if (*tp > X_SCHAR_MAX) status = NC_ERANGE;)
PAD_PUTN_SCHAR(uint,   if (*tp > X_SCHAR_MAX) status = NC_ERANGE;)
PAD_PUTN_SCHAR(uint64, if (*tp > X_SCHAR_MAX) status = NC_ERANGE;)

PAD_PUTN_SCHAR(short,  if (*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN) status = NC_ERANGE;)
PAD_PUTN_SCHAR(int,    if (*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN) status = NC_ERANGE;)
PAD_PUTN_SCHAR(long,   if (*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN) status = NC_ERANGE;)
PAD_PUTN_SCHAR(float,  if (*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN) status = NC_ERANGE;)
PAD_PUTN_SCHAR(double, if (*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN) status = NC_ERANGE;)
PAD_PUTN_SCHAR(int64,  if (*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN) status = NC_ERANGE;)

dnl PAD_PUTN_SCHAR(uchar,  NO_CHECK_SCHAR_RANGE)
/* wkliao: In netcdf3, there is no no range check for schar_uchar case. This
 * does not seem right ...
 */

dnl PUTN_SCHAR(uchar,  (0))
/* wkliao: In netcdf3, there is no no range check for schar_uchar case. That
 * does not seem right ...
 */
