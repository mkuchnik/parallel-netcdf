dnl Process this m4 file to produce 'C' language file.
dnl
dnl If you see this line, you can ignore the next one.
/* Do not edit this file. It is produced from the corresponding .m4 source */
dnl
/*
 *  Copyright (C) 2003, Northwestern University and Argonne National Laboratory
 *  See COPYRIGHT notice in top-level directory.
 */
/* $Id$ */

#if HAVE_CONFIG_H
# include <ncconfig.h>
#endif

#include <mpi.h>

#include "nc.h"
#include "ncx.h"

/* ftype is the variable's nc_type defined in file, eg. int64
 * btype is the I/O buffer's C data type, eg. long long
 * buftype is I/O bufer's MPI data type, eg. MPI_UNSIGNED_LONG_LONG
 * apitype is data type appeared in the API names, eg. ncmpi_get_vara_longlong
 */

/*---- uchar ----------------------------------------------------------------*/

/* do not check for range error, as netCDF specification make a special
 * case for type conversion between uchar and scahr:
 * http://www.unidata.ucar.edu/software/netcdf/docs_rc/data_type.html#type_conversion
 * The _uchar and _schar functions were introduced in netCDF-3 to eliminate
 * an ambiguity, and support both signed and unsigned byte data. In
 * netCDF-2, whether the external NC_BYTE type represented signed or
 * unsigned values was left up to the user. In netcdf-3, we treat NC_BYTE
 * as signed for the purposes of conversion to short, int, long, float, or
 * double. (Of course, no conversion takes place when the internal type is
 * signed char.) In the _uchar functions, we treat NC_BYTE as if it were
 * unsigned. Thus, no NC_ERANGE error can occur converting between NC_BYTE
 * and unsigned char.
 */

/*----< ncmpix_getn_uchar_schar() >------------------------------------------*/
int
ncmpix_getn_uchar_schar(const void **xpp, MPI_Offset nelems, schar *tp)
{
    /* file type is uchar, buffer type is schar */
    memcpy(tp, *xpp, nelems);
    *xpp = (void *)((char *)(*xpp) + nelems);

    return NC_NOERR;
}

/*----< ncmpix_getn_uchar_uchar() >------------------------------------------*/
int
ncmpix_getn_uchar_uchar(const void **xpp, MPI_Offset nelems, uchar *tp)
{
    /* file type is uchar, buffer type is uchar */
    memcpy(tp, *xpp, nelems);
    *xpp = (void *)((char *)(*xpp) + nelems);

    return NC_NOERR;
}

dnl
dnl GETN_UCHAR(xpp, nelems, tp)
dnl
define(`GETN_UCHAR',dnl
`dnl
/*----< ncmpix_getn_uchar_$1() >----------------------------------------------*/
int
ncmpix_getn_uchar_$1(const void **xpp, MPI_Offset nelems, $1 *tp)
{
    /* there is no ENDIANness issue, as uchar is 1 byte */
    uchar *xp = (uchar *) *xpp;
    while (nelems-- != 0)
        *tp++ = *xp++;
    *xpp = (const void *)xp;

    return NC_NOERR;
}
')dnl

GETN_UCHAR(short)
GETN_UCHAR(int)
GETN_UCHAR(long)
GETN_UCHAR(float)
GETN_UCHAR(double)
GETN_UCHAR(ushort)
GETN_UCHAR(uint)
GETN_UCHAR(int64)
GETN_UCHAR(uint64)

/*----< ncmpix_pad_getn_uchar_uchar() >--------------------------------------*/
int
ncmpix_pad_getn_uchar_uchar(const void **xpp, MPI_Offset nelems, uchar *tp)
{
    MPI_Offset rndup = nelems % X_ALIGN;
    if (rndup) rndup = X_ALIGN - rndup;

    memcpy(tp, *xpp, nelems);
    *xpp = (void *)((char *)(*xpp) + nelems + rndup);

    return NC_NOERR;
}

/*----< ncmpix_pad_getn_uchar_schar() >--------------------------------------*/
int
ncmpix_pad_getn_uchar_schar(const void **xpp, MPI_Offset nelems, schar *tp)
{
    MPI_Offset rndup = nelems % X_ALIGN;
    if (rndup) rndup = X_ALIGN - rndup;

    memcpy(tp, *xpp, nelems);
    *xpp = (void *)((char *)(*xpp) + nelems + rndup);

    return NC_NOERR;
}

dnl
dnl PAD_GETN_UCHAR(xpp, nelems, tp)
dnl
define(`PAD_GETN_UCHAR',dnl
`dnl
/*----< ncmpix_getn_uchar_$1() >----------------------------------------------*/
int
ncmpix_pad_getn_uchar_$1(const void **xpp, MPI_Offset nelems, $1 *tp)
{
    MPI_Offset rndup = nelems % X_ALIGN;
    if (rndup) rndup = X_ALIGN - rndup;

    /* there is no ENDIANness issue, as uchar is 1 byte */
    uchar *xp = (uchar *) *xpp;
    while (nelems-- != 0)
        *tp++ = *xp++;
    *xpp = (void *)((char *)(*xpp) + rndup);

    return NC_NOERR;
}
')dnl

PAD_GETN_UCHAR(short)
PAD_GETN_UCHAR(int)
PAD_GETN_UCHAR(long)
PAD_GETN_UCHAR(float)
PAD_GETN_UCHAR(double)
PAD_GETN_UCHAR(ushort)
PAD_GETN_UCHAR(uint)
PAD_GETN_UCHAR(int64)
PAD_GETN_UCHAR(uint64)


/*----< ncmpix_putn_uchar_uchar() >------------------------------------------*/
int
ncmpix_putn_uchar_uchar(void **xpp, MPI_Offset nelems, const uchar *tp)
{
    memcpy(*xpp, tp, nelems);
    *xpp = (void *)((char *)(*xpp) + nelems);

    return NC_NOERR;
}

/*----< ncmpix_putn_uchar_schar() >------------------------------------------*/
int
ncmpix_putn_uchar_schar(void **xpp, MPI_Offset nelems, const schar *tp)
{
    memcpy(*xpp, tp, nelems);
    *xpp = (void *)((char *)(*xpp) + nelems);

    return NC_NOERR;
}

dnl
dnl PUTN_UCHAR(xpp, nelems, tp)
dnl
define(`PUTN_UCHAR',dnl
`dnl
/*----< ncmpix_putn_uchar_$1() >----------------------------------------------*/
int
ncmpix_putn_uchar_$1(void **xpp, MPI_Offset nelems, const $1 *tp)
{
    int status=NC_NOERR;
    uchar *xp = (uchar *) *xpp;

    while (nelems-- != 0) {
        $2           /* check if can fit into uchar */
        *xp++ = (uchar) *tp++;
    }
    *xpp = (void *)xp;

    return status;
}
')dnl

PUTN_UCHAR(short,  if (*tp > X_UCHAR_MAX || *tp < 0) status = NC_ERANGE;)
PUTN_UCHAR(int,    if (*tp > X_UCHAR_MAX || *tp < 0) status = NC_ERANGE;)
PUTN_UCHAR(long,   if (*tp > X_UCHAR_MAX || *tp < 0) status = NC_ERANGE;)
PUTN_UCHAR(float,  if (*tp > X_UCHAR_MAX || *tp < 0) status = NC_ERANGE;)
PUTN_UCHAR(double, if (*tp > X_UCHAR_MAX || *tp < 0) status = NC_ERANGE;)
PUTN_UCHAR(int64,  if (*tp > X_UCHAR_MAX || *tp < 0) status = NC_ERANGE;)
PUTN_UCHAR(ushort, if (*tp > X_UCHAR_MAX) status = NC_ERANGE;)
PUTN_UCHAR(uint,   if (*tp > X_UCHAR_MAX) status = NC_ERANGE;)
PUTN_UCHAR(uint64, if (*tp > X_UCHAR_MAX) status = NC_ERANGE;)

/*----< ncmpix_pad_putn_uchar_uchar() >--------------------------------------*/
int
ncmpix_pad_putn_uchar_uchar(void **xpp, MPI_Offset nelems, const uchar *tp)
{
    MPI_Offset rndup = nelems % X_ALIGN;
    if (rndup) rndup = X_ALIGN - rndup;

    memcpy(*xpp, tp, nelems);
    *xpp = (void *)((char *)(*xpp) + nelems);

    if (rndup) {
        memcpy(*xpp, nada, rndup);
        *xpp = (void *)((char *)(*xpp) + rndup);
    }

    return NC_NOERR;
}

/*----< ncmpix_pad_putn_uchar_schar() >--------------------------------------*/
int
ncmpix_pad_putn_uchar_schar(void **xpp, MPI_Offset nelems, const schar *tp)
{
    MPI_Offset rndup = nelems % X_ALIGN;
    if (rndup) rndup = X_ALIGN - rndup;

    memcpy(*xpp, tp, nelems);
    *xpp = (void *)((char *)(*xpp) + nelems);

    if (rndup) {
        memcpy(*xpp, nada, rndup);
        *xpp = (void *)((char *)(*xpp) + rndup);
    }

    return NC_NOERR;
}

dnl
dnl PAD_PUTN_UCHAR(xpp, nelems, tp)
dnl
define(`PAD_PUTN_UCHAR',dnl
`dnl
/*----< ncmpix_pad_putn_uchar_$1() >------------------------------------------*/
int
ncmpix_pad_putn_uchar_$1(void **xpp, MPI_Offset nelems, const $1 *tp)
{
    int status=NC_NOERR;
    uchar *xp = (uchar *) *xpp;

    MPI_Offset rndup = nelems % X_ALIGN;
    if (rndup) rndup = X_ALIGN - rndup;

    while (nelems-- != 0) {
        $2         /* check if can fit into uchar */
        *xp++ = (uchar) *tp++;
    }

    if (rndup) {
        memcpy(xp, nada, rndup);
        xp += rndup;
    }
    *xpp = (void *)xp;

    return status;
}
')dnl

PAD_PUTN_UCHAR(short,  if (*tp > X_UCHAR_MAX || *tp < 0) status = NC_ERANGE;)
PAD_PUTN_UCHAR(int,    if (*tp > X_UCHAR_MAX || *tp < 0) status = NC_ERANGE;)
PAD_PUTN_UCHAR(long,   if (*tp > X_UCHAR_MAX || *tp < 0) status = NC_ERANGE;)
PAD_PUTN_UCHAR(float,  if (*tp > X_UCHAR_MAX || *tp < 0) status = NC_ERANGE;)
PAD_PUTN_UCHAR(double, if (*tp > X_UCHAR_MAX || *tp < 0) status = NC_ERANGE;)
PAD_PUTN_UCHAR(int64,  if (*tp > X_UCHAR_MAX || *tp < 0) status = NC_ERANGE;)
PAD_PUTN_UCHAR(ushort, if (*tp > X_UCHAR_MAX) status = NC_ERANGE;)
PAD_PUTN_UCHAR(uint,   if (*tp > X_UCHAR_MAX) status = NC_ERANGE;)
PAD_PUTN_UCHAR(uint64, if (*tp > X_UCHAR_MAX) status = NC_ERANGE;)


