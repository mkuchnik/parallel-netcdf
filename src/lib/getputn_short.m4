dnl Process this m4 file to produce 'C' language file.
dnl
dnl If you see this line, you can ignore the next one.
/* Do not edit this file. It is produced from the corresponding .m4 source */
dnl
/*
 *  Copyright (C) 2003, Northwestern University and Argonne National Laboratory
 *  See COPYRIGHT notice in top-level directory.
 */
/* $Id$ */

#if HAVE_CONFIG_H
# include <ncconfig.h>
#endif

#include <mpi.h>

#include "nc.h"
#include "ncx.h"

/* ftype is the variable's nc_type defined in file, eg. int64
 * btype is the I/O buffer's C data type, eg. long long
 * buftype is I/O bufer's MPI data type, eg. MPI_UNSIGNED_LONG_LONG
 * apitype is data type appeared in the API names, eg. ncmpi_get_vara_longlong
 */

/*---- x_short --------------------------------------------------------------*/

#if SHORT_MAX == X_SHORT_MAX
    typedef short ix_short;
    #define SIZEOF_IX_SHORT  SIZEOF_SHORT
    #define IX_SHORT_MAX     SHORT_MAX
#elif INT_MAX >= X_SHORT_MAX
    typedef int ix_short;
    #define SIZEOF_IX_SHORT  SIZEOF_INT
    #define IX_SHORT_MAX     INT_MAX
#elif LONG_MAX >= X_SHORT_MAX
    typedef long ix_short;
    #define SIZEOF_IX_SHORT  SIZEOF_LONG
    #define IX_SHORT_MAX     LONG_MAX
#else
    #error "ix_short ix_ushort implementation"
#endif

static void
get_ix_short(const void *xp, ix_short *ip)
{
    const uchar *cp = (const uchar *) xp;
    *ip = *cp++ << 8;
#if SIZEOF_IX_SHORT > X_SIZEOF_SHORT
    if (*ip & 0x8000) {
        /* extern is negative */
        *ip |= (~(0xffff)); /* N.B. Assumes "twos complement" */
    }
#endif
    *ip |= *cp; 
}

static void
put_ix_short(void *xp, const ix_short *ip)
{
    uchar *cp = (uchar *) xp;
    *cp++ = (*ip) >> 8;
    *cp = (*ip) & 0xff;
}


#if X_SIZEOF_SHORT != SIZEOF_SHORT
/*----< ncmpix_get_short_short() >-------------------------------------------*/
static int
ncmpix_get_short_short(const void *xp, short *ip)
{
#if SIZEOF_IX_SHORT == SIZEOF_SHORT && IX_SHORT_MAX == SHORT_MAX
    get_ix_short(xp, (ix_short *)ip);
    return NC_NOERR;
#else
    ix_short xx;
    get_ix_short(xp, &xx);
    *ip = xx;
#   if IX_SHORT_MAX > SHORT_MAX
    if (xx > SHORT_MAX || xx < SHORT_MIN)
        return NC_ERANGE;
#   endif
    return NC_NOERR;
#endif
}
#endif

/*----< ncmpix_get_short_int() >---------------------------------------------*/
static int
ncmpix_get_short_int(const void *xp, int *ip)
{
#if SIZEOF_IX_SHORT == SIZEOF_INT && IX_SHORT_MAX == INT_MAX
    get_ix_short(xp, (ix_short *)ip);
    return NC_NOERR;
#else
    ix_short xx;
    get_ix_short(xp, &xx);
    *ip = xx;
#   if IX_SHORT_MAX > INT_MAX
    if (xx > INT_MAX || xx < INT_MIN)
        return NC_ERANGE;
#   endif
    return NC_NOERR;
#endif
}

/*----< ncmpix_get_short_long() >--------------------------------------------*/
static int
ncmpix_get_short_long(const void *xp, long *ip)
{
#if SIZEOF_IX_SHORT == SIZEOF_LONG && IX_SHORT_MAX == LONG_MAX
    get_ix_short(xp, (ix_short *)ip);
    return NC_NOERR;
#else
    /* assert(LONG_MAX >= X_SHORT_MAX); */
    ix_short xx;
    get_ix_short(xp, &xx);
    *ip = xx;
    return NC_NOERR;
#endif
}

dnl
dnl GET_SHORT(xp, ip)
dnl
define(`GET_SHORT',dnl
`dnl
/*----< ncmpix_get_short_$1() >-----------------------------------------------*/
#define GET_SHORT(btype, range_check)
static int
ncmpix_get_short_$1(const void *xp, $1 *ip)
{
    ix_short xx;
    get_ix_short(xp, &xx); /* get a short in the form of local Endianness */
    *ip = xx;              /* typecast to $1 */
    $2
    return NC_NOERR;
}
')dnl

GET_SHORT(schar,  if (xx > SCHAR_MAX || xx < SCHAR_MIN) return NC_ERANGE;)
GET_SHORT(uchar,  if (xx > UCHAR_MAX || xx < 0)         return NC_ERANGE;)
GET_SHORT(float)
GET_SHORT(double)
GET_SHORT(int64)
GET_SHORT(ushort, if (xx < 0) return NC_ERANGE;)
GET_SHORT(uint,   if (xx < 0) return NC_ERANGE;)
GET_SHORT(uint64, if (xx < 0) return NC_ERANGE;)


/*----< ncmpix_put_short_schar() >-------------------------------------------*/
static int
ncmpix_put_short_schar(void *xp, const schar *ip)
{
    uchar *cp = (uchar *) xp;
    
    /* copy the signed bit from schar to short */
    if (*ip & 0x80)    /* 0x80 = 10000000(bin) = -127(dec) */
        /* ip is negative */
        *cp++ = 0xff;  /* 0xff = 11111111(bin) = -0(dec) */
        /* now the higher 8 bits are all 1s */
    else
        /* ip is positive */
        *cp++ = 0;

    *cp = (uchar)*ip;  /* the lower 8-bits */
    return NC_NOERR;
}

static int
ncmpix_put_short_uchar(void *xp, const uchar *ip)
{
    uchar *cp = (uchar *) xp;
    *cp++ = 0;
    *cp = *ip;
    return NC_NOERR;
}

#if X_SIZEOF_SHORT != SIZEOF_SHORT
static int
ncmpix_put_short_short(void *xp, const short *ip)
{
#if SIZEOF_IX_SHORT == SIZEOF_SHORT && X_SHORT_MAX == SHORT_MAX
    put_ix_short(xp, (const ix_short *)ip);
    return NC_NOERR;
#else
    ix_short xx = (ix_short)*ip;
    put_ix_short(xp, &xx);
# if X_SHORT_MAX < SHORT_MAX
    if (*ip > X_SHORT_MAX || *ip < X_SHORT_MIN)
        return NC_ERANGE;
# endif
    return NC_NOERR;
#endif
}
#endif

static int
ncmpix_put_short_int(void *xp, const int *ip)
{
#if SIZEOF_IX_SHORT == SIZEOF_INT && X_SHORT_MAX == INT_MAX
    put_ix_short(xp, (const ix_short *)ip);
    return NC_NOERR;
#else
    ix_short xx = (ix_short)*ip;  /* typecasting int to short */
    put_ix_short(xp, &xx);
# if X_SHORT_MAX < INT_MAX
    if (*ip > X_SHORT_MAX || *ip < X_SHORT_MIN)
        return NC_ERANGE;
# endif
    return NC_NOERR;
#endif
}

static int
ncmpix_put_short_long(void *xp, const long *ip)
{
#if SIZEOF_IX_SHORT == SIZEOF_LONG && X_SHORT_MAX == LONG_MAX
    put_ix_short(xp, (const ix_short *)ip);
    return NC_NOERR;
#else
    ix_short xx = (ix_short)*ip;
    put_ix_short(xp, &xx);
# if X_SHORT_MAX < LONG_MAX
    if (*ip > X_SHORT_MAX || *ip < X_SHORT_MIN)
        return NC_ERANGE;
# endif
    return NC_NOERR;
#endif
}

dnl
dnl PUT_SHORT(xp, ip)
dnl
define(`PUT_SHORT',dnl
`dnl
/*----< ncmpix_put_short_$1() >-----------------------------------------------*/
#define PUT_SHORT(btype, range_check)
static int
ncmpix_put_short_$1(void *xp, const $1 *ip)
{
    ix_short xx = (ix_short) *ip;
    put_ix_short(xp, &xx);
    $2
    return NC_NOERR;
}
')dnl

PUT_SHORT(float,  if (*ip > X_SHORT_MAX || *ip < X_SHORT_MIN) return NC_ERANGE;)
PUT_SHORT(double, if (*ip > X_SHORT_MAX || *ip < X_SHORT_MIN) return NC_ERANGE;)
PUT_SHORT(int64,  if (*ip > X_SHORT_MAX || *ip < X_SHORT_MIN) return NC_ERANGE;)
PUT_SHORT(ushort, if (*ip > X_SHORT_MAX) return NC_ERANGE;)
PUT_SHORT(uint,   if (*ip > X_SHORT_MAX) return NC_ERANGE;)
PUT_SHORT(uint64, if (*ip > X_SHORT_MAX) return NC_ERANGE;)

dnl
dnl GETN_SHORT(xpp, nelems, tp)
dnl
define(`GETN_SHORT',dnl
`dnl
/*----< ncmpix_$1() >---------------------------------------------------------*/
int
ncmpix_$1(const void **xpp, MPI_Offset nelems, $2 *tp)
{
    const char *xp = (const char *) *xpp;
    int status = NC_NOERR;

    for ( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++) {
        const int lstatus = ncmpix_get_short_$2(xp, tp);
        if (lstatus != NC_NOERR) status = lstatus;
    }

    if ($3 && nelems % 2 != 0)
        xp += X_SIZEOF_SHORT;

    *xpp = (void *)xp;
    return status;
}
')dnl

GETN_SHORT(    getn_short_schar,  schar,  0)
GETN_SHORT(    getn_short_uchar,  uchar,  0)
GETN_SHORT(    getn_short_int,    int,    0)
GETN_SHORT(    getn_short_long,   long,   0)
GETN_SHORT(    getn_short_float,  float,  0)
GETN_SHORT(    getn_short_double, double, 0)
GETN_SHORT(    getn_short_ushort, ushort, 0)
GETN_SHORT(    getn_short_uint,   uint,   0)
GETN_SHORT(    getn_short_int64,  int64,  0)
GETN_SHORT(    getn_short_uint64, uint64, 0)

GETN_SHORT(pad_getn_short_schar,  schar,  1)
GETN_SHORT(pad_getn_short_uchar,  uchar,  1)
GETN_SHORT(pad_getn_short_int,    int,    1)
GETN_SHORT(pad_getn_short_long,   long,   1)
GETN_SHORT(pad_getn_short_float,  float,  1)
GETN_SHORT(pad_getn_short_double, double, 1)
GETN_SHORT(pad_getn_short_ushort, ushort, 1)
GETN_SHORT(pad_getn_short_uint,   uint,   1)
GETN_SHORT(pad_getn_short_int64,  int64,  1)
GETN_SHORT(pad_getn_short_uint64, uint64, 1)

/*----< ncmpix_getn_short_short() >------------------------------------------*/
/*----< ncmpix_pad_getn_short_short() >--------------------------------------*/
#if X_SIZEOF_SHORT == SIZEOF_SHORT
/* optimized version */
int
ncmpix_getn_short_short(const void **xpp, MPI_Offset nelems, short *tp)
{
# ifdef WORDS_BIGENDIAN
    memcpy(tp, *xpp, nelems * sizeof(short));
# else
    ncmpii_swapn2b(tp, *xpp, nelems);
# endif
    *xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_SHORT);
    return NC_NOERR;
}
int
ncmpix_pad_getn_short_short(const void **xpp, MPI_Offset nelems, short *tp)
{
    const MPI_Offset rndup = nelems % 2;
# ifdef WORDS_BIGENDIAN
    memcpy(tp, *xpp, nelems * sizeof(short));
# else
    ncmpii_swapn2b(tp, *xpp, nelems);
# endif
    *xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_SHORT + rndup);
    return NC_NOERR;
}
#else
GETN_SHORT(    getn_short_short,  short,  0)
GETN_SHORT(pad_getn_short_short,  short,  1)
#endif

dnl
dnl PUTN_SHORT(xpp, nelems, tp)
dnl
define(`PUTN_SHORT',dnl
`dnl
/*----< ncmpix_$1() >---------------------------------------------------------*/
int
ncmpix_$1(void **xpp, MPI_Offset nelems, const $2 *tp)
{   /* put tp[nelems] (type $2) to xpp[nelems] (type short) */
    char *xp = (char *) *xpp;
    int status = NC_NOERR;

    for ( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++) {
        int lstatus = ncmpix_put_short_$2(xp, tp);
        if (lstatus != NC_NOERR) status = lstatus;
    }

    if ($3 && nelems % 2 != 0) {
        memcpy(xp, nada, X_SIZEOF_SHORT);
        xp += X_SIZEOF_SHORT;
    }

    *xpp = (void *)xp;
    return status;
}
')dnl

PUTN_SHORT(    putn_short_schar,  schar,  0)
PUTN_SHORT(    putn_short_uchar,  uchar,  0)
PUTN_SHORT(    putn_short_int,    int,    0)
PUTN_SHORT(    putn_short_long,   long,   0)
PUTN_SHORT(    putn_short_float,  float,  0)
PUTN_SHORT(    putn_short_double, double, 0)
PUTN_SHORT(    putn_short_ushort, ushort, 0)
PUTN_SHORT(    putn_short_uint,   uint,   0)
PUTN_SHORT(    putn_short_int64,  int64,  0)
PUTN_SHORT(    putn_short_uint64, uint64, 0)

PUTN_SHORT(pad_putn_short_schar,  schar,  1)
PUTN_SHORT(pad_putn_short_uchar,  uchar,  1)
PUTN_SHORT(pad_putn_short_int,    int,    1)
PUTN_SHORT(pad_putn_short_long,   long,   1)
PUTN_SHORT(pad_putn_short_float,  float,  1)
PUTN_SHORT(pad_putn_short_double, double, 1)
PUTN_SHORT(pad_putn_short_ushort, ushort, 1)
PUTN_SHORT(pad_putn_short_uint,   uint,   1)
PUTN_SHORT(pad_putn_short_int64,  int64,  1)
PUTN_SHORT(pad_putn_short_uint64, uint64, 1)

/*----< ncmpix_putn_short_short() >------------------------------------------*/
/*----< ncmpix_pad_putn_short_short() >--------------------------------------*/
#if X_SIZEOF_SHORT == SIZEOF_SHORT
/* optimized version */
int
ncmpix_putn_short_short(void **xpp, MPI_Offset nelems, const short *tp)
{
# ifdef WORDS_BIGENDIAN
    memcpy(*xpp, tp, nelems * X_SIZEOF_SHORT);
# else
    ncmpii_swapn2b(*xpp, tp, nelems);
# endif
    *xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_SHORT);
    return NC_NOERR;
}
int
ncmpix_pad_putn_short_short(void **xpp, MPI_Offset nelems, const short *tp)
{
    const MPI_Offset rndup = nelems % 2;
# ifdef WORDS_BIGENDIAN
    memcpy(*xpp, tp, nelems * X_SIZEOF_SHORT);
# else
    ncmpii_swapn2b(*xpp, tp, nelems);
# endif
    *xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_SHORT + rndup);
    return NC_NOERR;
}
#else
PUTN_SHORT(    putn_short_short,  short,  0)
PUTN_SHORT(pad_putn_short_short,  short,  1)
#endif

