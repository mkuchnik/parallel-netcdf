dnl Process this m4 file to produce 'C' language file.
dnl
dnl If you see this line, you can ignore the next one.
/* Do not edit this file. It is produced from the corresponding .m4 source */
dnl
/*
 *  Copyright (C) 2003, Northwestern University and Argonne National Laboratory
 *  See COPYRIGHT notice in top-level directory.
 */
/* $Id$ */

#if HAVE_CONFIG_H
# include <ncconfig.h>
#endif

#include <stdio.h>
#include <unistd.h>
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#include <assert.h>

#include <mpi.h>

#include "nc.h"
#include "ncx.h"
#include "ncmpidtype.h"
#include "macro.h"
#ifdef ENABLE_SUBFILING
#include "subfile.h"
#endif


define(`CollIndep', `ifelse(`$1', `_all', `COLL_IO', `INDEP_IO')')dnl
define(`ReadWrite', `ifelse(`$1', `get',  `READ_REQ', `WRITE_REQ')')dnl
define(`BufConst',  `ifelse(`$1', `put',  `const')')dnl

dnl
dnl VAR_FLEXIBLE
dnl
define(`VAR_FLEXIBLE',dnl
`dnl
/*----< ncmpi_$1_var$2() >---------------------------------------------------*/
int
ncmpi_$1_var$2(int                ncid,
               int                varid,
               BufConst($1) void *buf,
               MPI_Offset         bufcount,
               MPI_Datatype       buftype)
{
    int         status;
    NC         *ncp;
    NC_var     *varp=NULL;
    MPI_Offset *start, *count;

    SANITY_CHECK(ncid, ncp, varp, ReadWrite($1), CollIndep($2), status)
    GET_FULL_DIMENSIONS(start, count)

    /* $1_var is a special case of $1_vars */
    status = ncmpii_getput_vars(ncp, varp, start, count, NULL, (void*)buf,
                                bufcount, buftype, ReadWrite($1), CollIndep($2), 0);
    if (varp->ndims > 0) NCI_Free(start);
    return status;
}
')dnl

dnl PnetCDF flexible APIs
VAR_FLEXIBLE(put)
VAR_FLEXIBLE(get)
VAR_FLEXIBLE(put, _all)
VAR_FLEXIBLE(get, _all)

dnl
dnl VAR(ncid, varid, op)
dnl
define(`VAR',dnl
`dnl
/*----< ncmpi_$1_var_$3$2() >--------------------------------------------------*/
int
ncmpi_$1_var_$3$2(int              ncid,
                  int              varid,
                  BufConst($1) $4 *op)
{
    int         status;
    NC         *ncp;
    NC_var     *varp=NULL;
    MPI_Offset  nelems, *start, *count;

    SANITY_CHECK(ncid, ncp, varp, ReadWrite($1), CollIndep($2), status)
    GET_TOTAL_NUM_ELEMENTS(nelems)
    GET_FULL_DIMENSIONS(start, count)

    /* $1_var is a special case of $1_vars */
    status = ncmpii_getput_vars(ncp, varp, start, count, NULL, (void*)op,
                                nelems, $5, ReadWrite($1), CollIndep($2), 0);
    if (varp->ndims > 0) NCI_Free(start);
    return status;
}
')dnl

VAR(put,     , text,      char,               MPI_CHAR)
VAR(put,     , schar,     schar,              MPI_BYTE)
VAR(put,     , uchar,     uchar,              MPI_UNSIGNED_CHAR)
VAR(put,     , short,     short,              MPI_SHORT)
VAR(put,     , ushort,    ushort,             MPI_UNSIGNED_SHORT)
VAR(put,     , int,       int,                MPI_INT)
VAR(put,     , uint,      uint,               MPI_UNSIGNED)
VAR(put,     , long,      long,               MPI_LONG)
VAR(put,     , float,     float,              MPI_FLOAT)
VAR(put,     , double,    double,             MPI_DOUBLE)
VAR(put,     , longlong,  long long,          MPI_LONG_LONG_INT)
VAR(put,     , ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG)

VAR(put, _all, text,      char,               MPI_CHAR)
VAR(put, _all, schar,     schar,              MPI_BYTE)
VAR(put, _all, uchar,     uchar,              MPI_UNSIGNED_CHAR)
VAR(put, _all, short,     short,              MPI_SHORT)
VAR(put, _all, ushort,    ushort,             MPI_UNSIGNED_SHORT)
VAR(put, _all, int,       int,                MPI_INT)
VAR(put, _all, uint,      uint,               MPI_UNSIGNED)
VAR(put, _all, long,      long,               MPI_LONG)
VAR(put, _all, float,     float,              MPI_FLOAT)
VAR(put, _all, double,    double,             MPI_DOUBLE)
VAR(put, _all, longlong,  long long,          MPI_LONG_LONG_INT)
VAR(put, _all, ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG)

VAR(get,     , text,      char,               MPI_CHAR)
VAR(get,     , schar,     schar,              MPI_BYTE)
VAR(get,     , uchar,     uchar,              MPI_UNSIGNED_CHAR)
VAR(get,     , short,     short,              MPI_SHORT)
VAR(get,     , ushort,    ushort,             MPI_UNSIGNED_SHORT)
VAR(get,     , int,       int,                MPI_INT)
VAR(get,     , uint,      uint,               MPI_UNSIGNED)
VAR(get,     , long,      long,               MPI_LONG)
VAR(get,     , float,     float,              MPI_FLOAT)
VAR(get,     , double,    double,             MPI_DOUBLE)
VAR(get,     , longlong,  long long,          MPI_LONG_LONG_INT)
VAR(get,     , ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG)

VAR(get, _all, text,      char,               MPI_CHAR)
VAR(get, _all, schar,     schar,              MPI_BYTE)
VAR(get, _all, uchar,     uchar,              MPI_UNSIGNED_CHAR)
VAR(get, _all, short,     short,              MPI_SHORT)
VAR(get, _all, ushort,    ushort,             MPI_UNSIGNED_SHORT)
VAR(get, _all, int,       int,                MPI_INT)
VAR(get, _all, uint,      uint,               MPI_UNSIGNED)
VAR(get, _all, long,      long,               MPI_LONG)
VAR(get, _all, float,     float,              MPI_FLOAT)
VAR(get, _all, double,    double,             MPI_DOUBLE)
VAR(get, _all, longlong,  long long,          MPI_LONG_LONG_INT)
VAR(get, _all, ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG)

dnl
dnl VAR1_FLEXIBLE
dnl
define(`VAR1_FLEXIBLE',dnl
`dnl
/*----< ncmpi_$1_var1$2() >--------------------------------------------------*/
int
ncmpi_$1_var1$2(int                ncid,
                int                varid,
                const MPI_Offset   start[],
                BufConst($1) void *buf,
                MPI_Offset         bufcount,
                MPI_Datatype       buftype)
{
    int         status;
    NC         *ncp;
    NC_var     *varp=NULL;
    MPI_Offset *count;

    SANITY_CHECK(ncid, ncp, varp, ReadWrite($1), CollIndep($2), status)
    GET_ONE_COUNT(count)

    status = ncmpii_getput_vars(ncp, varp, start, count, NULL, (void*)buf,
                                bufcount, buftype, ReadWrite($1), CollIndep($2), 0);
    if (varp->ndims > 0) NCI_Free(count);
    return status;
}
')dnl

VAR1_FLEXIBLE(put)
VAR1_FLEXIBLE(get)
VAR1_FLEXIBLE(put, _all)
VAR1_FLEXIBLE(get, _all)

dnl
dnl VAR1
dnl
define(`VAR1',dnl
`dnl
/*----< ncmpi_$1_var1_$3$2() >-----------------------------------------------*/
int
ncmpi_$1_var1_$3$2(int               ncid,
                   int               varid,
                   const MPI_Offset  start[],
                   BufConst($1) $4  *op)
{
    int         status;
    NC         *ncp;
    NC_var     *varp=NULL;
    MPI_Offset *count;

    SANITY_CHECK(ncid, ncp, varp, ReadWrite($1), CollIndep($2), status)
    GET_ONE_COUNT(count)

    /* $1_var1 is a special case of $1_vars */
    status = ncmpii_getput_vars(ncp, varp, start, count, NULL, (void*)op,
                                1, $5, ReadWrite($1), CollIndep($2), 0);
    if (varp->ndims > 0) NCI_Free(count);
    return status;
}
')dnl

VAR1(put,     , text,      char,               MPI_CHAR)
VAR1(put,     , schar,     schar,              MPI_BYTE)
VAR1(put,     , uchar,     uchar,              MPI_UNSIGNED_CHAR)
VAR1(put,     , short,     short,              MPI_SHORT)
VAR1(put,     , ushort,    ushort,             MPI_UNSIGNED_SHORT)
VAR1(put,     , int,       int,                MPI_INT)
VAR1(put,     , uint,      uint,               MPI_UNSIGNED)
VAR1(put,     , long,      long,               MPI_LONG)
VAR1(put,     , float,     float,              MPI_FLOAT)
VAR1(put,     , double,    double,             MPI_DOUBLE)
VAR1(put,     , longlong,  long long,          MPI_LONG_LONG_INT)
VAR1(put,     , ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG)

VAR1(put, _all, text,      char,               MPI_CHAR)
VAR1(put, _all, schar,     schar,              MPI_BYTE)
VAR1(put, _all, uchar,     uchar,              MPI_UNSIGNED_CHAR)
VAR1(put, _all, short,     short,              MPI_SHORT)
VAR1(put, _all, ushort,    ushort,             MPI_UNSIGNED_SHORT)
VAR1(put, _all, int,       int,                MPI_INT)
VAR1(put, _all, uint,      uint,               MPI_UNSIGNED)
VAR1(put, _all, long,      long,               MPI_LONG)
VAR1(put, _all, float,     float,              MPI_FLOAT)
VAR1(put, _all, double,    double,             MPI_DOUBLE)
VAR1(put, _all, longlong,  long long,          MPI_LONG_LONG_INT)
VAR1(put, _all, ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG)

VAR1(get,     , text,      char,               MPI_CHAR)
VAR1(get,     , schar,     schar,              MPI_BYTE)
VAR1(get,     , uchar,     uchar,              MPI_UNSIGNED_CHAR)
VAR1(get,     , short,     short,              MPI_SHORT)
VAR1(get,     , ushort,    ushort,             MPI_UNSIGNED_SHORT)
VAR1(get,     , int,       int,                MPI_INT)
VAR1(get,     , uint,      uint,               MPI_UNSIGNED)
VAR1(get,     , long,      long,               MPI_LONG)
VAR1(get,     , float,     float,              MPI_FLOAT)
VAR1(get,     , double,    double,             MPI_DOUBLE)
VAR1(get,     , longlong,  long long,          MPI_LONG_LONG_INT)
VAR1(get,     , ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG)

VAR1(get, _all, text,      char,               MPI_CHAR)
VAR1(get, _all, schar,     schar,              MPI_BYTE)
VAR1(get, _all, uchar,     uchar,              MPI_UNSIGNED_CHAR)
VAR1(get, _all, short,     short,              MPI_SHORT)
VAR1(get, _all, ushort,    ushort,             MPI_UNSIGNED_SHORT)
VAR1(get, _all, int,       int,                MPI_INT)
VAR1(get, _all, uint,      uint,               MPI_UNSIGNED)
VAR1(get, _all, long,      long,               MPI_LONG)
VAR1(get, _all, float,     float,              MPI_FLOAT)
VAR1(get, _all, double,    double,             MPI_DOUBLE)
VAR1(get, _all, longlong,  long long,          MPI_LONG_LONG_INT)
VAR1(get, _all, ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG)

dnl
dnl VARA_FLEXIBLE
dnl
define(`VARA_FLEXIBLE',dnl
`dnl
/*----< ncmpi_$1_vara$2() >--------------------------------------------------*/
int
ncmpi_$1_vara$2(int                ncid,
                int                varid,
                const MPI_Offset   start[],
                const MPI_Offset   count[],
                BufConst($1) void *buf,
                MPI_Offset         bufcount,
                MPI_Datatype       buftype)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    SANITY_CHECK(ncid, ncp, varp, ReadWrite($1), CollIndep($2), status)

    /* $1_vara is a special case of $1_vars */
    return ncmpii_getput_vars(ncp, varp, start, count, NULL, (void*)buf,
                              bufcount, buftype, ReadWrite($1), CollIndep($2), 0);
}
')dnl

dnl PnetCDF flexible APIs
VARA_FLEXIBLE(put)
VARA_FLEXIBLE(get)
VARA_FLEXIBLE(put, _all)
VARA_FLEXIBLE(get, _all)

dnl
dnl VARA
dnl
define(`VARA',dnl
`dnl
/*----< ncmpi_$1_vara_$3$2() >-------------------------------------------------*/
int
ncmpi_$1_vara_$3$2(int               ncid,
                   int               varid,
                   const MPI_Offset  start[],
                   const MPI_Offset  count[],
                   BufConst($1) $4  *op)
{
    int         status;
    NC         *ncp;
    NC_var     *varp=NULL;
    MPI_Offset  nelems;

    SANITY_CHECK(ncid, ncp, varp, ReadWrite($1), CollIndep($2), status)
    GET_NUM_ELEMENTS(nelems)

    /* $1_vara is a special case of $1_vars */
    return ncmpii_getput_vars(ncp, varp, start, count, NULL, (void*)op,
                              nelems, $5, ReadWrite($1), CollIndep($2), 0);
}
')dnl

VARA(put,     , text,      char,               MPI_CHAR)
VARA(put,     , schar,     schar,              MPI_BYTE)
VARA(put,     , uchar,     uchar,              MPI_UNSIGNED_CHAR)
VARA(put,     , short,     short,              MPI_SHORT)
VARA(put,     , ushort,    ushort,             MPI_UNSIGNED_SHORT)
VARA(put,     , int,       int,                MPI_INT)
VARA(put,     , uint,      uint,               MPI_UNSIGNED)
VARA(put,     , long,      long,               MPI_LONG)
VARA(put,     , float,     float,              MPI_FLOAT)
VARA(put,     , double,    double,             MPI_DOUBLE)
VARA(put,     , longlong,  long long,          MPI_LONG_LONG_INT)
VARA(put,     , ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG)

VARA(put, _all, text,      char,               MPI_CHAR)
VARA(put, _all, schar,     schar,              MPI_BYTE)
VARA(put, _all, uchar,     uchar,              MPI_UNSIGNED_CHAR)
VARA(put, _all, short,     short,              MPI_SHORT)
VARA(put, _all, ushort,    ushort,             MPI_UNSIGNED_SHORT)
VARA(put, _all, int,       int,                MPI_INT)
VARA(put, _all, uint,      uint,               MPI_UNSIGNED)
VARA(put, _all, long,      long,               MPI_LONG)
VARA(put, _all, float,     float,              MPI_FLOAT)
VARA(put, _all, double,    double,             MPI_DOUBLE)
VARA(put, _all, longlong,  long long,          MPI_LONG_LONG_INT)
VARA(put, _all, ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG)

VARA(get,     , text,      char,               MPI_CHAR)
VARA(get,     , schar,     schar,              MPI_BYTE)
VARA(get,     , uchar,     uchar,              MPI_UNSIGNED_CHAR)
VARA(get,     , short,     short,              MPI_SHORT)
VARA(get,     , ushort,    ushort,             MPI_UNSIGNED_SHORT)
VARA(get,     , int,       int,                MPI_INT)
VARA(get,     , uint,      uint,               MPI_UNSIGNED)
VARA(get,     , long,      long,               MPI_LONG)
VARA(get,     , float,     float,              MPI_FLOAT)
VARA(get,     , double,    double,             MPI_DOUBLE)
VARA(get,     , longlong,  long long,          MPI_LONG_LONG_INT)
VARA(get,     , ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG)

VARA(get, _all, text,      char,               MPI_CHAR)
VARA(get, _all, schar,     schar,              MPI_BYTE)
VARA(get, _all, uchar,     uchar,              MPI_UNSIGNED_CHAR)
VARA(get, _all, short,     short,              MPI_SHORT)
VARA(get, _all, ushort,    ushort,             MPI_UNSIGNED_SHORT)
VARA(get, _all, int,       int,                MPI_INT)
VARA(get, _all, uint,      uint,               MPI_UNSIGNED)
VARA(get, _all, long,      long,               MPI_LONG)
VARA(get, _all, float,     float,              MPI_FLOAT)
VARA(get, _all, double,    double,             MPI_DOUBLE)
VARA(get, _all, longlong,  long long,          MPI_LONG_LONG_INT)
VARA(get, _all, ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG)

dnl
dnl VARS_FLEXIBLE
dnl
define(`VARS_FLEXIBLE',dnl
`dnl
/*----< ncmpi_$1_vars$2() >--------------------------------------------------*/
int
ncmpi_$1_vars$2(int                ncid,
                int                varid,
                const MPI_Offset   start[],
                const MPI_Offset   count[],
                const MPI_Offset   stride[],
                BufConst($1) void *buf,
                MPI_Offset         bufcount,
                MPI_Datatype       buftype)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    SANITY_CHECK(ncid, ncp, varp, ReadWrite($1), CollIndep($2), status)

    return ncmpii_getput_vars(ncp, varp, start, count, stride, (void*)buf,
                              bufcount, buftype, ReadWrite($1), CollIndep($2), 0);
}
')dnl

dnl PnetCDF flexible APIs
VARS_FLEXIBLE(put)
VARS_FLEXIBLE(get)
VARS_FLEXIBLE(put, _all)
VARS_FLEXIBLE(get, _all)

dnl
dnl VARS
dnl
define(`VARS',dnl
`dnl
/*----< ncmpi_$1_vars_$3$2() >-------------------------------------------------*/
int
ncmpi_$1_vars_$3$2(int               ncid,
                   int               varid,
                   const MPI_Offset  start[],
                   const MPI_Offset  count[],
                   const MPI_Offset  stride[],
                   BufConst($1) $4  *op)
{
    int         status;
    NC         *ncp;
    NC_var     *varp=NULL;
    MPI_Offset  nelems;

    SANITY_CHECK(ncid, ncp, varp, ReadWrite($1), CollIndep($2), status)
    GET_NUM_ELEMENTS(nelems)

    return ncmpii_getput_vars(ncp, varp, start, count, stride, (void*)op,
                              nelems, $5, ReadWrite($1), CollIndep($2), 0);
}
')dnl

VARS(put,     , text,      char,               MPI_CHAR)
VARS(put,     , schar,     schar,              MPI_BYTE)
VARS(put,     , uchar,     uchar,              MPI_UNSIGNED_CHAR)
VARS(put,     , short,     short,              MPI_SHORT)
VARS(put,     , ushort,    ushort,             MPI_UNSIGNED_SHORT)
VARS(put,     , int,       int,                MPI_INT)
VARS(put,     , uint,      uint,               MPI_UNSIGNED)
VARS(put,     , long,      long,               MPI_LONG)
VARS(put,     , float,     float,              MPI_FLOAT)
VARS(put,     , double,    double,             MPI_DOUBLE)
VARS(put,     , longlong,  long long,          MPI_LONG_LONG_INT)
VARS(put,     , ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG)

VARS(put, _all, text,      char,               MPI_CHAR)
VARS(put, _all, schar,     schar,              MPI_BYTE)
VARS(put, _all, uchar,     uchar,              MPI_UNSIGNED_CHAR)
VARS(put, _all, short,     short,              MPI_SHORT)
VARS(put, _all, ushort,    ushort,             MPI_UNSIGNED_SHORT)
VARS(put, _all, int,       int,                MPI_INT)
VARS(put, _all, uint,      uint,               MPI_UNSIGNED)
VARS(put, _all, long,      long,               MPI_LONG)
VARS(put, _all, float,     float,              MPI_FLOAT)
VARS(put, _all, double,    double,             MPI_DOUBLE)
VARS(put, _all, longlong,  long long,          MPI_LONG_LONG_INT)
VARS(put, _all, ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG)

VARS(get,     , text,      char,               MPI_CHAR)
VARS(get,     , schar,     schar,              MPI_BYTE)
VARS(get,     , uchar,     uchar,              MPI_UNSIGNED_CHAR)
VARS(get,     , short,     short,              MPI_SHORT)
VARS(get,     , ushort,    ushort,             MPI_UNSIGNED_SHORT)
VARS(get,     , int,       int,                MPI_INT)
VARS(get,     , uint,      uint,               MPI_UNSIGNED)
VARS(get,     , long,      long,               MPI_LONG)
VARS(get,     , float,     float,              MPI_FLOAT)
VARS(get,     , double,    double,             MPI_DOUBLE)
VARS(get,     , longlong,  long long,          MPI_LONG_LONG_INT)
VARS(get,     , ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG)

VARS(get, _all, text,      char,               MPI_CHAR)
VARS(get, _all, schar,     schar,              MPI_BYTE)
VARS(get, _all, uchar,     uchar,              MPI_UNSIGNED_CHAR)
VARS(get, _all, short,     short,              MPI_SHORT)
VARS(get, _all, ushort,    ushort,             MPI_UNSIGNED_SHORT)
VARS(get, _all, int,       int,                MPI_INT)
VARS(get, _all, uint,      uint,               MPI_UNSIGNED)
VARS(get, _all, long,      long,               MPI_LONG)
VARS(get, _all, float,     float,              MPI_FLOAT)
VARS(get, _all, double,    double,             MPI_DOUBLE)
VARS(get, _all, longlong,  long long,          MPI_LONG_LONG_INT)
VARS(get, _all, ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG)


/* for write case, buf needs to swapped back if swapped previously */
#define FINAL_CLEAN_UP {                                                       \
    if (is_buf_swapped) /* byte-swap back to buf's original contents */        \
        ncmpii_in_swapn(buf, fnelems, ncmpix_len_nctype(varp->type));          \
                                                                               \
    if (xbuf != NULL && xbuf != cbuf) NCI_Free(xbuf);                          \
    if (cbuf != NULL && cbuf !=  buf) NCI_Free(cbuf);                          \
}

/* buffer layers:

   User Level              buf     (user defined buffer of MPI_Datatype)
   MPI Datatype Level      cbuf    (contiguous buffer of ptype)
   NetCDF XDR Level        xbuf    (XDR I/O buffer)

   The principle of buffer management is:

   for put_vars:
     1. pack buf to cbuf based on buftype
     2. type convert and byte swap cbuf to xbuf
     3. write from xbuf
     4. byte swap the buf back to its original, if it is swapped
     5. free up temp buffers, cbuf and xbuf if they were allocated separately

   for get_vars:
     1. allocate cbuf
     2. allocate xbuf
     3. read to xbuf
     4. type convert and byte swap xbuf to cbuf
     5. unpack cbuf to buf based on buftype
     6. free up temp buffers, cbuf and xbuf if they were allocated separately
*/

/*----< ncmpii_getput_vars() >------------------------------------------------*/
int
ncmpii_getput_vars(NC               *ncp,
                   NC_var           *varp,
                   const MPI_Offset  start[],
                   const MPI_Offset  count[],
                   const MPI_Offset  stride[],
                   void             *buf,
                   MPI_Offset        bufcount,
                   MPI_Datatype      buftype,  /* data type of the bufer */
                   int               rw_flag,
                   int               io_method,
                   int               isTempBuf) /* if is an internal buf */
{
    void *xbuf=NULL, *cbuf=NULL;
    int isderived, el_size, mpireturn;
    int warning, err, status; /* err is for API abort and status is not */
    int buftype_is_contig, need_swap=0, need_convert=0, is_buf_swapped=0;
    MPI_Offset fnelems=1, bnelems, nbytes=0, offset=0;
    MPI_Status mpistatus;
    MPI_Datatype ptype, filetype=MPI_BYTE;
    MPI_File fh=MPI_FILE_NULL;

    /* "API error" will abort this API call, but not the entire program */
    err = status = warning = NC_NOERR;

#ifdef ENABLE_SUBFILING
    /* call a separate routine if variable is stored in subfiles */
    if (varp->num_subfiles > 1) {
#ifdef SUBFILE_DEBUG
        printf("var(%s) is stored in subfiles\n", varp->name->cp);
#endif
        return ncmpii_subfile_getput_vars(ncp, varp, start, count, stride,
                                          buf, bufcount, buftype,
                                          rw_flag, io_method);
    }
#endif

    if (varp->ndims > 0 && start == NULL) {
        err = NC_ENULLSTART;
        goto err_check;
    }
    if (varp->ndims > 0 && count == NULL) {
        err = NC_ENULLCOUNT;
        goto err_check;
    }

    if (io_method == COLL_IO)
        fh = ncp->nciop->collective_fh;
    else
        fh = ncp->nciop->independent_fh;

    if (buftype == MPI_DATATYPE_NULL) {
        /* In this case, bufcount is ignored and will be recalculated to match
         * count[]. Note buf's data type must match the data type of
         * variable defined in the file - no data conversion will be done.
         */
        int i;
        bufcount = 1;
        for (i=0; i<varp->ndims; i++) {
            if (count[i] < 0) { /* no negative count[] */
                err = NC_ENEGATIVECNT;
                goto err_check;
            }
            bufcount *= count[i];
        }
        /* assign buftype match with the variable's data type */
        buftype = ncmpii_nc2mpitype(varp->type);
    }

    /* Check if buftype is contiguous (for flexible APIs). If no, we must pack
     * it into a contiguous buffer, named cbuf
     * find the ptype (primitive MPI data type) from buftype
     * el_size is the element size of ptype
     * bnelems is the total number of ptype elements in the I/O buffer, buf
     * fnelems is the number of nc variable elements in nc_type
     * nbytes is the amount of read/write in bytes
     */
    err = ncmpii_dtype_decode(buftype, &ptype, &el_size, &bnelems,
                              &isderived, &buftype_is_contig);
    /* bnelems now is the number of ptype in a buftype */
    if (err != NC_NOERR) goto err_check;

    /* type conversion is prohibited between types char and non-char */
    err = NCMPII_ECHAR(varp->type, ptype);
    if (err != NC_NOERR) goto err_check;

    CHECK_NELEMS(varp, fnelems, count, bnelems, bufcount, nbytes, err)

    if (nbytes != (int)nbytes) {
        /* because nbytes will be used for the argument of "cout" in MPI
         * read/write calls and "count" is of type int */
        err = NC_EINTOVERFLOW;
        if (io_method == INDEP_IO) return err;
        goto err_check;
    }
    /* bnelems now is the number of ptype in the whole buf */
    /* warning is set in CHECK_NELEMS() */

    if (bnelems == 0) { /* if this process has nothing to read/write */
        if (io_method == INDEP_IO)
            return NCcoordck(ncp, varp, start, rw_flag);
#ifdef ZERO_COUNT_IGNORE_OTHER_ERRORS
        else
        /* for collective I/O, even bnelems == 0, must go on to participate
           the collective calls: MPI_File_set_view and collective read/write */
            goto err_check;
#endif
    }

    if (!buftype_is_contig && bufcount > 0 && bnelems > 0) {
        /* buf is noncontiguous in memory */
        int outsize = bnelems * el_size;
        cbuf = NCI_Malloc(outsize);

        if (rw_flag == WRITE_REQ) {
            /* pack buf into cbuf, a contiguous buffer */
            int position = 0;
            MPI_Pack(buf, bufcount, buftype, cbuf, outsize, &position,
                     MPI_COMM_SELF);
        }
    } else {
        cbuf = (void*) buf;
    }

    /* Check if we need type convert and byte swap cbuf (into xbuf) */
    need_swap = ncmpii_need_swap(varp->type, ptype);
    need_convert = ncmpii_need_convert(varp->type, ptype);
    if (need_convert) {
        /* allocate new buffer for data type conversion */
        xbuf = NCI_Malloc(nbytes);

        if (rw_flag == WRITE_REQ) {
            /* type convert and byte-swap cbuf to xbuf */
            DATATYPE_PUT_CONVERT(varp->type, xbuf, cbuf, bnelems, ptype, err)
            /* retain the first error status */
            if (status == NC_NOERR) status = err;
        }
    } else if (need_swap) {
        if (rw_flag == WRITE_REQ) {
#ifdef DISABLE_IN_PLACE_SWAP
            if (isTempBuf == 0 && cbuf == buf) {
                /* allocate cbuf and copy buf to cbuf, cbuf is to be freed */
                cbuf = NCI_Malloc(nbytes);
                memcpy(cbuf, buf, nbytes);
            }
#endif
            /* perform array in-place byte swap on cbuf */
            ncmpii_in_swapn(cbuf, fnelems, ncmpix_len_nctype(varp->type));
            is_buf_swapped = (cbuf == buf) ? 1 : 0;
            /* is_buf_swapped indicates if the contents of the original user
             * buffer, buf, have been changed, i.e. byte swapped. */
        }
        xbuf = cbuf;
    } else {
        /* else, no type conversion or byte swap */
        xbuf = cbuf;
    }
    /* xbuf is the buffer whose data has been converted into the external
     * data type, ready to be written to the netCDF file. Similar for read,
     * after read from file, the contents of xbuf are in external type
     */

    /* if record variables are too big (so big that we cannot store the
     * stride between records in an MPI_Aint, for example) then we will
     * have to process this one record at a time.
     */

    /* check if the request is contiguous in file */
    if (stride == NULL && ncmpii_is_request_contiguous(ncp, varp, start, count)) {
        err = NCedgeck(ncp, varp, start, count);

        if (err != NC_NOERR ||
            (rw_flag == READ_REQ && IS_RECVAR(varp) &&
             start[0] + count[0] > NC_get_numrecs(ncp))) { /* API error */
            err = NCcoordck(ncp, varp, start, rw_flag);
            if (err == NC_NOERR) err = NC_EEDGE;
            goto err_check;
        }

        /* this is a contiguous file access, no need to set filetype */
        err = ncmpii_get_offset(ncp, varp, start, NULL, NULL, rw_flag, &offset);
        /* if start[] is out of defined size, then this will return
         * NC_EINVALCOORDS error */
        if (err != NC_NOERR) /* API error */
            goto err_check;
    }
    else {
        /* this request is non-contiguous in file, create the mpi file type */
        int blocklen, is_filetype_contig;
        err = ncmpii_vars_create_filetype(ncp, varp, start, count, stride,
                                          rw_flag, &blocklen, &offset,
                                          &filetype, &is_filetype_contig);
        if (err != NC_NOERR) /* API error */
            goto err_check;
    }

err_check:
    /* check API error from any proc before going into a collective call.
     * optimization: to avoid MPI_Allreduce to check parameters at
     * every call, we assume caller does the right thing most of the
     * time.  If caller passed in bad parameters, we'll still conduct a
     * zero-byte operation (everyone has to participate in the
     * collective I/O call) but return error */
    if (err != NC_NOERR || bufcount == 0) {
        /* release allocated resources */
        if (filetype != MPI_BYTE)
            MPI_Type_free(&filetype);
        filetype = MPI_BYTE;

        FINAL_CLEAN_UP  /* swap back put buffer and free temp buffers */
        if (io_method == COLL_IO)
            ncmpii_getput_zero_req(ncp, rw_flag, IS_RECVAR(varp));

        return err;
    }

    /* MPI_File_set_view is a collective if (io_method == COLL_IO) */
    TRACE_IO(MPI_File_set_view)(fh, offset, MPI_BYTE, filetype,
                                "native", MPI_INFO_NULL);
    if (mpireturn != MPI_SUCCESS) {
        err = ncmpii_handle_error(mpireturn, "MPI_File_set_view");
        /* return the first encountered error if there is any */
        if (status == NC_NOERR) status = err;
    }

    if (filetype != MPI_BYTE)
        MPI_Type_free(&filetype);

    if (rw_flag == WRITE_REQ) {
        if (io_method == COLL_IO) {
            TRACE_IO(MPI_File_write_all)(fh, xbuf, nbytes, MPI_BYTE, &mpistatus);
            if (mpireturn != MPI_SUCCESS) {
                err = ncmpii_handle_error(mpireturn, "MPI_File_write_all");
                /* return the first encountered error if there is any */
                if (status == NC_NOERR && err == NC_EFILE) status = NC_EWRITE;
            }
        }
        else { /* io_method == INDEP_IO */
            TRACE_IO(MPI_File_write)(fh, xbuf, nbytes, MPI_BYTE, &mpistatus);
            if (mpireturn != MPI_SUCCESS) {
                err = ncmpii_handle_error(mpireturn, "MPI_File_write");
                /* return the first encountered error if there is any */
                if (status == NC_NOERR && err == NC_EFILE) status = NC_EWRITE;
            }
        }
        int put_size;
        MPI_Get_count(&mpistatus, MPI_BYTE, &put_size);
        ncp->nciop->put_size += put_size;
    }
    else {  /* rw_flag == READ_REQ */
        if (io_method == COLL_IO) {
            TRACE_IO(MPI_File_read_all)(fh, xbuf, nbytes, MPI_BYTE, &mpistatus);
            if (mpireturn != MPI_SUCCESS) {
                err = ncmpii_handle_error(mpireturn, "MPI_File_read_all");
                /* return the first encountered error if there is any */
                if (status == NC_NOERR && err == NC_EFILE) status = NC_EREAD;
            }
        }
        else { /* io_method == INDEP_IO */
            TRACE_IO(MPI_File_read)(fh, xbuf, nbytes, MPI_BYTE, &mpistatus);
            if (mpireturn != MPI_SUCCESS) {
                err = ncmpii_handle_error(mpireturn, "MPI_File_read");
                /* return the first encountered error if there is any */
                if (status == NC_NOERR && err == NC_EFILE) status = NC_EREAD;
            }
        }
        int get_size;
        MPI_Get_count(&mpistatus, MPI_BYTE, &get_size);
        ncp->nciop->get_size += get_size;
    }

    /* reset the file view so the entire file is visible again */
    TRACE_IO(MPI_File_set_view)(fh, 0, MPI_BYTE, MPI_BYTE, "native", MPI_INFO_NULL);

    if (rw_flag == READ_REQ) {
        if (need_convert) {
            /* type conversion + swap from xbuf to cbuf */
            DATATYPE_GET_CONVERT(varp->type, xbuf, cbuf, bnelems, ptype, err)
            /* retain the first error status */
            if (status == NC_NOERR) status = err;
        } else if (need_swap) {
            /* perform array in-place byte swap from xbuf to cbuf */
            ncmpii_in_swapn(cbuf, fnelems, ncmpix_len_nctype(varp->type));
        }

        if (!buftype_is_contig && bufcount > 0 && bnelems > 0) {
            /* unpack cbuf, a contiguous buffer, to buf using buftype */
            int position = 0;
            int insize = bnelems * el_size;
            MPI_Unpack(cbuf, insize, &position, buf, bufcount, buftype,
                       MPI_COMM_SELF);
        }
    }
    else { /* WRITE_REQ */
        if (IS_RECVAR(varp)) {
            /* update header's number of records in memory */
            MPI_Offset new_numrecs;

            if (status == NC_NOERR) {
                if (stride == NULL)
                    new_numrecs = start[0] + count[0];
                else
                    new_numrecs = start[0] + (count[0] - 1) * stride[0] + 1;
            }
            else
                new_numrecs = ncp->numrecs;

            if (io_method == INDEP_IO) {
                /* FIXME: if we update numrecs to file now, race condition
                   can happen. Hence, we delay the update till file close or
                   exit independent data mode. Note numrecs in memory may be
                   inconsistent and obsolete till then.
                 */
                if (ncp->numrecs < new_numrecs) {
                    ncp->numrecs = new_numrecs;
                    set_NC_ndirty(ncp);
                }
            }
            else /* COLL_IO */
                ncmpii_sync_numrecs(ncp, new_numrecs);
        }
    }

    FINAL_CLEAN_UP  /* swap back the put buffer and free temp buffers */

    return ((warning != NC_NOERR) ? warning : status);
}

/* buffer layers:

   User Level              buf     (user defined buffer of MPI_Datatype)
   MPI Datatype Level      cbuf    (contiguous buffer of ptype)
   NetCDF XDR Level        xbuf    (XDR I/O buffer)
*/

/* varm: there maybe two layer of memory layout (remapping):
         one is specified by MPI derived datatype,
         the other is specified by imap[],
         it's encouraged to use only one option of them,
         though using both of them are supported.

   user buffer:                         |--------------------------|

   mpi derived datatype view:           |------|  |------|  |------|

   logic (contig) memory datastream:       |------|------|------|

   imap view:                              |--| |--|    |--| |--|

   contig I/O datastream (internal represent): |--|--|--|--|

   These two layers of memory layout will both be represented in MPI
   derived datatype, and if double layers of memory layout is used,
   we need to elimilate the upper one passed in MPI_Datatype parameter
   from the user, by packing it to logic contig memory datastream view.

   for put_varm:
     1. pack buf to lbuf based on buftype
     2. create imap_type based on imap
     3. pack lbuf to cbuf based on imap_type
     4. type convert and byte swap cbuf to xbuf
     5. write from xbuf
     6. byte swap the buf, if it is swapped
     7. free up temp buffers

   for get_varm:
     1. allocate lbuf
     2. create imap_type based on imap
     3. allocate cbuf
     4. allocate xbuf
     5. read to xbuf
     6. type convert and byte swap xbuf to cbuf
     7. unpack cbuf to lbuf based on imap_type
     8. unpack lbuf to buf based on buftype
*/

dnl
dnl VARM_FLEXIBLE
dnl
define(`VARM_FLEXIBLE',dnl
`dnl
/*----< ncmpi_$1_varm$2() >--------------------------------------------------*/
int
ncmpi_$1_varm$2(int                ncid,
                int                varid,
                const MPI_Offset   start[],
                const MPI_Offset   count[],
                const MPI_Offset   stride[],
                const MPI_Offset   imap[],
                BufConst($1) void *buf,
                MPI_Offset         bufcount,
                MPI_Datatype       buftype)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    SANITY_CHECK(ncid, ncp, varp, ReadWrite($1), CollIndep($2), status)

    return ncmpii_getput_varm(ncp, varp, start, count, stride, imap,
                              (void*)buf, bufcount, buftype, ReadWrite($1), CollIndep($2));
}
')dnl

dnl PnetCDF flexible APIs
VARM_FLEXIBLE(put)
VARM_FLEXIBLE(get)
VARM_FLEXIBLE(put, _all)
VARM_FLEXIBLE(get, _all)

dnl
dnl VARM
dnl
define(`VARM',dnl
`dnl
/*----< ncmpi_$1_varm_$3$2() >-------------------------------------------------*/
int
ncmpi_$1_varm_$3$2(int               ncid,
                   int               varid,
                   const MPI_Offset  start[],
                   const MPI_Offset  count[],
                   const MPI_Offset  stride[],
                   const MPI_Offset  imap[],
                   BufConst($1) $4  *op)
{
    int         status;
    NC         *ncp;
    NC_var     *varp=NULL;
    MPI_Offset  nelems;

    SANITY_CHECK(ncid, ncp, varp, ReadWrite($1), CollIndep($2), status)
    GET_NUM_ELEMENTS(nelems)

    return ncmpii_getput_varm(ncp, varp, start, count, stride, imap,
                              (void*)op, nelems, $5, ReadWrite($1), CollIndep($2));
}
')dnl

VARM(put,     , text,      char,               MPI_CHAR)
VARM(put,     , schar,     schar,              MPI_BYTE)
VARM(put,     , uchar,     uchar,              MPI_UNSIGNED_CHAR)
VARM(put,     , short,     short,              MPI_SHORT)
VARM(put,     , ushort,    ushort,             MPI_UNSIGNED_SHORT)
VARM(put,     , int,       int,                MPI_INT)
VARM(put,     , uint,      uint,               MPI_UNSIGNED)
VARM(put,     , long,      long,               MPI_LONG)
VARM(put,     , float,     float,              MPI_FLOAT)
VARM(put,     , double,    double,             MPI_DOUBLE)
VARM(put,     , longlong,  long long,          MPI_LONG_LONG_INT)
VARM(put,     , ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG)

VARM(put, _all, text,      char,               MPI_CHAR)
VARM(put, _all, schar,     schar,              MPI_BYTE)
VARM(put, _all, uchar,     uchar,              MPI_UNSIGNED_CHAR)
VARM(put, _all, short,     short,              MPI_SHORT)
VARM(put, _all, ushort,    ushort,             MPI_UNSIGNED_SHORT)
VARM(put, _all, int,       int,                MPI_INT)
VARM(put, _all, uint,      uint,               MPI_UNSIGNED)
VARM(put, _all, long,      long,               MPI_LONG)
VARM(put, _all, float,     float,              MPI_FLOAT)
VARM(put, _all, double,    double,             MPI_DOUBLE)
VARM(put, _all, longlong,  long long,          MPI_LONG_LONG_INT)
VARM(put, _all, ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG)

VARM(get,     , text,      char,               MPI_CHAR)
VARM(get,     , schar,     schar,              MPI_BYTE)
VARM(get,     , uchar,     uchar,              MPI_UNSIGNED_CHAR)
VARM(get,     , short,     short,              MPI_SHORT)
VARM(get,     , ushort,    ushort,             MPI_UNSIGNED_SHORT)
VARM(get,     , int,       int,                MPI_INT)
VARM(get,     , uint,      uint,               MPI_UNSIGNED)
VARM(get,     , long,      long,               MPI_LONG)
VARM(get,     , float,     float,              MPI_FLOAT)
VARM(get,     , double,    double,             MPI_DOUBLE)
VARM(get,     , longlong,  long long,          MPI_LONG_LONG_INT)
VARM(get,     , ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG)

VARM(get, _all, text,      char,               MPI_CHAR)
VARM(get, _all, schar,     schar,              MPI_BYTE)
VARM(get, _all, uchar,     uchar,              MPI_UNSIGNED_CHAR)
VARM(get, _all, short,     short,              MPI_SHORT)
VARM(get, _all, ushort,    ushort,             MPI_UNSIGNED_SHORT)
VARM(get, _all, int,       int,                MPI_INT)
VARM(get, _all, uint,      uint,               MPI_UNSIGNED)
VARM(get, _all, long,      long,               MPI_LONG)
VARM(get, _all, float,     float,              MPI_FLOAT)
VARM(get, _all, double,    double,             MPI_DOUBLE)
VARM(get, _all, longlong,  long long,          MPI_LONG_LONG_INT)
VARM(get, _all, ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG)


/*----< ncmpii_getput_varm() >------------------------------------------------*/
int
ncmpii_getput_varm(NC               *ncp,
                   NC_var           *varp,
                   const MPI_Offset  start[],
                   const MPI_Offset  count[],
                   const MPI_Offset  stride[],
                   const MPI_Offset  imap[],
                   void             *buf,
                   MPI_Offset        bufcount,
                   MPI_Datatype      buftype,
                   int               rw_flag,    /* WRITE_REQ or READ_REQ */
                   int               io_method)  /* COLL_IO or INDEP_IO */
{
    void *lbuf=NULL, *cbuf=NULL;
    int err, status, warning; /* err is for API abort and status is not */
    int dim, imap_contig_blocklen, el_size, buftype_is_contig, isderived;
    MPI_Offset lnelems, cnelems=0;
    MPI_Datatype ptype, tmptype, imaptype;

    /* "API error" will abort this API call, but not the entire program */
    err = status = warning = NC_NOERR;
    imaptype = MPI_DATATYPE_NULL;

    /* check if this is a true varm call */
    if (imap == NULL || varp->ndims == 0) {
        /* when imap == NULL, no mapping, same as vars.
           when varp->ndims == 0, reduced to scalar var, only one value
           at one fixed place */
        return ncmpii_getput_vars(ncp, varp, start, count, stride, buf,
                                  bufcount, buftype, rw_flag, io_method, 0);
    }

    /* continue to check if this is a true varm call:
     * test each dim's contiguity in imap[] until the 1st non-contiguous dim
     * is reached
     */
    imap_contig_blocklen = 1;
    dim = varp->ndims;
    while ( --dim >= 0 && imap_contig_blocklen == imap[dim] ) {
        if (count[dim] < 0) { /* API error */
            err = NC_ENEGATIVECNT;
            goto err_check;
        }
        imap_contig_blocklen *= count[dim];
    }
    if (dim == -1) /* not a true varm call, as imap is a contiguous layout */
        return ncmpii_getput_vars(ncp, varp, start, count, stride, buf,
                                  bufcount, buftype, rw_flag, io_method, 0);

    /* else case indicates we have a true varm call, as
     * imap gives non-contiguous layout, we will do pack/unpack I/O
     * buffer based on imap[], but first must check if buftype is NULL
     * (a match data type case). Otherwise check if buftype is contiguous
     * in case for flexible APIs.
     */

    if (buftype == MPI_DATATYPE_NULL) {
        /* In this case, bufcount is ignored and will be recalculated to match
         * count[]. Note buf's data type must match the data type of
         * variable defined in the file - no data conversion will be done.
         */
        int i;
        bufcount = 1;
        for (i=0; i<varp->ndims; i++) {
            if (count[i] < 0) { /* no negative count[] */
                err = NC_ENEGATIVECNT;
                goto err_check;
            }
            bufcount *= count[i];
        }
        /* assign buftype match with the variable's data type */
        buftype = ncmpii_nc2mpitype(varp->type);
    }

    /* find the ptype (primitive MPI data type) from buftype
     * el_size is the element size of ptype
     * lnelems is the number of ptype elements in the buftype
     */
    err = ncmpii_dtype_decode(buftype, &ptype, &el_size, &lnelems,
                              &isderived, &buftype_is_contig);
    if (err != NC_NOERR)  /* API error */
        goto err_check;

    if (!buftype_is_contig) {
        /* buftype is not a contiguous of ptypes: pack buf to lbuf, a
           contiguous buffer, using buftype */
        lnelems *= bufcount;
        if (rw_flag == WRITE_REQ && bufcount > 0 && lnelems > 0) {
            /* only write needs this packing */
            int position = 0;
            int outsize = lnelems*el_size;
            lbuf = NCI_Malloc(outsize);

            MPI_Pack(buf, bufcount, buftype, lbuf, outsize, &position,
                     MPI_COMM_SELF);
        }
    } else {
        lbuf = buf;
    }

    /* construct an MPI datatype based on imap[], and use it to pack lbuf
       to cbuf, another contiguous buffer */
    MPI_Type_vector(count[dim], imap_contig_blocklen, imap[dim],
                    ptype, &imaptype);
    MPI_Type_commit(&imaptype);
    cnelems = imap_contig_blocklen * count[dim];
    for (dim--; dim>=0; dim--) {
        if (count[dim] < 0) { /* API error */
            err = ((warning != NC_NOERR) ? warning : NC_ENEGATIVECNT);
            goto err_check;
        }
#ifdef HAVE_MPI_TYPE_CREATE_HVECTOR
        MPI_Type_create_hvector(count[dim], 1, (MPI_Aint)imap[dim]*el_size,
                                imaptype, &tmptype);
#else
        MPI_Type_hvector(count[dim], 1, imap[dim]*el_size, imaptype, &tmptype);
#endif
        MPI_Type_free(&imaptype);
        MPI_Type_commit(&tmptype);
        imaptype = tmptype;
        cnelems *= count[dim];
    }

    /* cbuf cannot be lbuf, as imap[] gives a non-contigous layout */
    cbuf = (void*) NCI_Malloc(cnelems*el_size);

    if (rw_flag == WRITE_REQ && cnelems > 0) {
        /* layout lbuf to cbuf, a contiguous buffer, based on imap */
        int position=0;
        int outsize = cnelems*el_size;

        MPI_Pack(lbuf, 1, imaptype, cbuf, outsize, &position, MPI_COMM_SELF);

        /* For write case, till now all request data has been packed into
           cbuf, so simply call ncmpii_getput_vars() to fulfill the write.
           lbuf is not needed anymore */
        if (lbuf != NULL && lbuf != buf) NCI_Free(lbuf);
        lbuf = NULL;
    }

err_check:
    /* check API error from any proc before going into a collective call.
     * optimization: to avoid MPI_Allreduce to check parameters at
     * every call, we assume caller does the right thing most of the
     * time.  If caller passed in bad parameters, we'll still conduct a
     * zero-byte operation (everyone has to participate in the
     * collective I/O call) but return error */
    if (err != NC_NOERR || bufcount == 0) {  /* handle the error */
        if (io_method == COLL_IO) {
            MPI_Offset *zeros;
            zeros = (MPI_Offset *) NCI_Calloc(varp->ndims, sizeof(MPI_Offset));
            ncmpii_getput_vars(ncp, varp, zeros, zeros, NULL, buf,
                               0, MPI_BYTE, rw_flag, io_method, 0);
            NCI_Free(zeros);
        }
        if (lbuf != NULL && lbuf != buf) NCI_Free(lbuf);
        if (cbuf != NULL)                NCI_Free(cbuf);
        if (imaptype != MPI_DATATYPE_NULL)
            MPI_Type_free(&imaptype);
        return err;
    }

    /* now, we can use cbuf and cnelems to call getput_vars */
    status = ncmpii_getput_vars(ncp, varp, start, count, stride, cbuf,
                                cnelems, ptype, rw_flag, io_method, 1);
    if (status != NC_NOERR)
        goto err_check2;

    if (rw_flag == READ_REQ) {
        int position, insize;
        /* now, cbuf contains the data read from file and they are all
           type converted and byte-swapped */

        if (!buftype_is_contig)
            /* buftype is not contiguous: unpack cbuf to lbuf, a contiguous
               buffer, using imap, so later lbuf can be unpacked to buf */
            lbuf = NCI_Malloc(lnelems*el_size);
        else
            lbuf = buf;

        /* layout cbuf, a contiguous buffer, to lbuf based on imap */
        if (cnelems > 0) {
            position = 0;
            insize = cnelems * el_size;
            MPI_Unpack(cbuf, insize, &position, lbuf, 1, imaptype, MPI_COMM_SELF);
        }

        /* layout lbuf, a contiguous buffer, to buf based on buftype */
        if (!buftype_is_contig && bufcount > 0) {
            position = 0;
            insize = lnelems * el_size;
            MPI_Unpack(lbuf, insize, &position, buf, bufcount, buftype, MPI_COMM_SELF);
        }
    }

err_check2:
    if (lbuf != NULL && lbuf != buf) NCI_Free(lbuf);
    if (cbuf != NULL)                NCI_Free(cbuf);

    if (imaptype != MPI_DATATYPE_NULL)
        MPI_Type_free(&imaptype);

    return ((warning != NC_NOERR) ? warning : status);
}
