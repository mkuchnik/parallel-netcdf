dnl Process this m4 file to produce 'C' language file.
dnl
dnl If you see this line, you can ignore the next one.
/* Do not edit this file. It is produced from the corresponding .m4 source */
dnl
/*
 *  Copyright (C) 2003, Northwestern University and Argonne National Laboratory
 *  See COPYRIGHT notice in top-level directory.
 */
/* $Id$ */

#if HAVE_CONFIG_H
# include <ncconfig.h>
#endif

#include <stdio.h>
#include <unistd.h>
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#include <assert.h>

#include <mpi.h>

#include "nc.h"
#include "ncx.h"
#include "ncmpidtype.h"
#include "macro.h"
#ifdef ENABLE_SUBFILING
#include "subfile.h"
#endif


dnl
dnl PUT_VAR(ncid, varid, buf, bufcount, buftype)
dnl
define(`PUT_VAR',dnl
`dnl
/*----< ncmpi_put_var$1() >---------------------------------------------------*/
int
ncmpi_put_var$1(int           ncid,
                int           varid,
                const void   *buf,
                MPI_Offset    bufcount,
                MPI_Datatype  buftype)
{
    int         status;
    NC         *ncp;
    NC_var     *varp=NULL;
    MPI_Offset *start, *count;

    SANITY_CHECK(ncid, ncp, varp, WRITE_REQ, $2, status)
    GET_FULL_DIMENSIONS(start, count)

    /* put_var is a special case of put_vars */
    status = ncmpii_getput_vars(ncp, varp, start, count, NULL, (void*)buf,
                                bufcount, buftype, WRITE_REQ, $2);
    if (varp->ndims > 0) NCI_Free(start);
    return status;
}
')dnl

dnl PnetCDF flexible APIs
PUT_VAR(    , INDEP_IO)
PUT_VAR(_all, COLL_IO)

dnl
dnl GET_VAR(ncid, varid, buf, bufcount, buftype)
dnl
define(`GET_VAR',dnl
`dnl
/*----< ncmpi_get_var$1() >---------------------------------------------------*/
int
ncmpi_get_var$1(int           ncid,
                int           varid,
                void         *buf,
                MPI_Offset    bufcount,
                MPI_Datatype  buftype)
{
    int         status;
    NC         *ncp;
    NC_var     *varp=NULL;
    MPI_Offset *start, *count;

    SANITY_CHECK(ncid, ncp, varp, READ_REQ, $2, status)
    GET_FULL_DIMENSIONS(start, count)

    /* get_var is a special case of get_vars */
    status = ncmpii_getput_vars(ncp, varp, start, count, NULL, buf,
                                bufcount, buftype, READ_REQ, $2);
    if (varp->ndims > 0) NCI_Free(start);
    return status;
}
')dnl

dnl PnetCDF flexible APIs
GET_VAR(    , INDEP_IO)
GET_VAR(_all, COLL_IO)

dnl
dnl PUT_VAR_TYPE(ncid, varid, op)
dnl
define(`PUT_VAR_TYPE',dnl
`dnl
/*----< ncmpi_put_var_$1() >--------------------------------------------------*/
int
ncmpi_put_var_$1(int       ncid,
                 int       varid,
                 const $2 *op)
{
    int         status;
    NC         *ncp;
    NC_var     *varp=NULL;
    MPI_Offset  nelems, *start, *count;

    SANITY_CHECK(ncid, ncp, varp, WRITE_REQ, $4, status)
    GET_TOTAL_NUM_ELEMENTS(nelems)
    GET_FULL_DIMENSIONS(start, count)

    /* put_var is a special case of put_vars */
    status = ncmpii_getput_vars(ncp, varp, start, count, NULL, (void*)op,
                                nelems, $3, WRITE_REQ, $4);
    if (varp->ndims > 0) NCI_Free(start);
    return status;
}
')dnl

PUT_VAR_TYPE(text,      char,               MPI_CHAR,               INDEP_IO)
PUT_VAR_TYPE(schar,     schar,              MPI_BYTE,               INDEP_IO)
PUT_VAR_TYPE(uchar,     uchar,              MPI_UNSIGNED_CHAR,      INDEP_IO)
PUT_VAR_TYPE(short,     short,              MPI_SHORT,              INDEP_IO)
PUT_VAR_TYPE(ushort,    ushort,             MPI_UNSIGNED_SHORT,     INDEP_IO)
PUT_VAR_TYPE(int,       int,                MPI_INT,                INDEP_IO)
PUT_VAR_TYPE(uint,      uint,               MPI_UNSIGNED,           INDEP_IO)
PUT_VAR_TYPE(long,      long,               MPI_LONG,               INDEP_IO)
PUT_VAR_TYPE(float,     float,              MPI_FLOAT,              INDEP_IO)
PUT_VAR_TYPE(double,    double,             MPI_DOUBLE,             INDEP_IO)
PUT_VAR_TYPE(longlong,  long long,          MPI_LONG_LONG_INT,      INDEP_IO)
PUT_VAR_TYPE(ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG, INDEP_IO)
dnl PUT_VAR_TYPE(string, char*,             MPI_CHAR,               INDEP_IO)
dnl string is not yet supported

PUT_VAR_TYPE(text_all,      char,               MPI_CHAR,               COLL_IO)
PUT_VAR_TYPE(schar_all,     schar,              MPI_BYTE,               COLL_IO)
PUT_VAR_TYPE(uchar_all,     uchar,              MPI_UNSIGNED_CHAR,      COLL_IO)
PUT_VAR_TYPE(short_all,     short,              MPI_SHORT,              COLL_IO)
PUT_VAR_TYPE(ushort_all,    ushort,             MPI_UNSIGNED_SHORT,     COLL_IO)
PUT_VAR_TYPE(int_all,       int,                MPI_INT,                COLL_IO)
PUT_VAR_TYPE(uint_all,      uint,               MPI_UNSIGNED,           COLL_IO)
PUT_VAR_TYPE(long_all,      long,               MPI_LONG,               COLL_IO)
PUT_VAR_TYPE(float_all,     float,              MPI_FLOAT,              COLL_IO)
PUT_VAR_TYPE(double_all,    double,             MPI_DOUBLE,             COLL_IO)
PUT_VAR_TYPE(longlong_all,  long long,          MPI_LONG_LONG_INT,      COLL_IO)
PUT_VAR_TYPE(ulonglong_all, unsigned long long, MPI_UNSIGNED_LONG_LONG, COLL_IO)
dnl PUT_VAR_TYPE(string_all, char*,             MPI_CHAR,               COLL_IO)
dnl string is not yet supported

dnl
dnl GET_VAR_TYPE(ncid, varid, ip)
dnl
define(`GET_VAR_TYPE',dnl
`dnl
/*----< ncmpi_get_var_$1() >--------------------------------------------------*/
int
ncmpi_get_var_$1(int  ncid,
                 int  varid,
                 $2  *ip)
{
    int         status;
    NC         *ncp;
    NC_var     *varp=NULL;
    MPI_Offset  nelems, *start, *count;

    SANITY_CHECK(ncid, ncp, varp, READ_REQ, $4, status)
    GET_TOTAL_NUM_ELEMENTS(nelems)
    GET_FULL_DIMENSIONS(start, count)

    /* get_var is a special case of get_vars */
    status = ncmpii_getput_vars(ncp, varp, start, count, NULL, ip,
                                nelems, $3, READ_REQ, $4);
    if (varp->ndims > 0) NCI_Free(start);
    return status;
}
')dnl

GET_VAR_TYPE(text,      char,               MPI_CHAR,               INDEP_IO)
GET_VAR_TYPE(schar,     schar,              MPI_BYTE,               INDEP_IO)
GET_VAR_TYPE(uchar,     uchar,              MPI_UNSIGNED_CHAR,      INDEP_IO)
GET_VAR_TYPE(short,     short,              MPI_SHORT,              INDEP_IO)
GET_VAR_TYPE(ushort,    ushort,             MPI_UNSIGNED_SHORT,     INDEP_IO)
GET_VAR_TYPE(int,       int,                MPI_INT,                INDEP_IO)
GET_VAR_TYPE(uint,      uint,               MPI_UNSIGNED,           INDEP_IO)
GET_VAR_TYPE(long,      long,               MPI_LONG,               INDEP_IO)
GET_VAR_TYPE(float,     float,              MPI_FLOAT,              INDEP_IO)
GET_VAR_TYPE(double,    double,             MPI_DOUBLE,             INDEP_IO)
GET_VAR_TYPE(longlong,  long long,          MPI_LONG_LONG_INT,      INDEP_IO)
GET_VAR_TYPE(ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG, INDEP_IO)
dnl GET_VAR_TYPE(string, char*,             MPI_CHAR,               INDEP_IO)
dnl string is not yet supported

GET_VAR_TYPE(text_all,      char,               MPI_CHAR,               COLL_IO)
GET_VAR_TYPE(schar_all,     schar,              MPI_BYTE,               COLL_IO)
GET_VAR_TYPE(uchar_all,     uchar,              MPI_UNSIGNED_CHAR,      COLL_IO)
GET_VAR_TYPE(short_all,     short,              MPI_SHORT,              COLL_IO)
GET_VAR_TYPE(ushort_all,    ushort,             MPI_UNSIGNED_SHORT,     COLL_IO)
GET_VAR_TYPE(int_all,       int,                MPI_INT,                COLL_IO)
GET_VAR_TYPE(uint_all,      uint,               MPI_UNSIGNED,           COLL_IO)
GET_VAR_TYPE(long_all,      long,               MPI_LONG,               COLL_IO)
GET_VAR_TYPE(float_all,     float,              MPI_FLOAT,              COLL_IO)
GET_VAR_TYPE(double_all,    double,             MPI_DOUBLE,             COLL_IO)
GET_VAR_TYPE(longlong_all,  long long,          MPI_LONG_LONG_INT,      COLL_IO)
GET_VAR_TYPE(ulonglong_all, unsigned long long, MPI_UNSIGNED_LONG_LONG, COLL_IO)
dnl GET_VAR_TYPE(string_all, char*,             MPI_CHAR,               COLL_IO)
dnl string is not yet supported

/*----< ncmpi_put_var1() >----------------------------------------------------*/
int
ncmpi_put_var1(int               ncid,
               int               varid,
               const MPI_Offset  start[],
               const void       *buf,
               MPI_Offset        bufcount,
               MPI_Datatype      buftype)
{
    int         status;
    NC         *ncp;
    NC_var     *varp=NULL;
    MPI_Offset *count;

    SANITY_CHECK(ncid, ncp, varp, WRITE_REQ, INDEP_IO, status)
    GET_ONE_COUNT(count)

    status = ncmpii_getput_vars(ncp, varp, start, count, NULL, (void*)buf,
                                bufcount, buftype, WRITE_REQ, INDEP_IO);
    if (varp->ndims > 0) NCI_Free(count);
    return status;
}

dnl
dnl PUT_VAR1_TYPE(ncid, varid, start, op)
dnl
define(`PUT_VAR1_TYPE',dnl
`dnl
/*----< ncmpi_put_var1_$1() >-------------------------------------------------*/
int
ncmpi_put_var1_$1(int               ncid,
                  int               varid,
                  const MPI_Offset  start[],
                  const $2         *op)
{
    int         status;
    NC         *ncp;
    NC_var     *varp=NULL;
    MPI_Offset *count;

    SANITY_CHECK(ncid, ncp, varp, WRITE_REQ, INDEP_IO, status)
    GET_ONE_COUNT(count)

    /* put_var1 is a special case of put_vars */
    status = ncmpii_getput_vars(ncp, varp, start, count, NULL, (void*)op,
                                1, $3, WRITE_REQ, INDEP_IO);
    if (varp->ndims > 0) NCI_Free(count);
    return status;
}
')dnl

PUT_VAR1_TYPE(text,      char,               MPI_CHAR)
PUT_VAR1_TYPE(schar,     schar,              MPI_BYTE)
PUT_VAR1_TYPE(uchar,     uchar,              MPI_UNSIGNED_CHAR)
PUT_VAR1_TYPE(short,     short,              MPI_SHORT)
PUT_VAR1_TYPE(ushort,    ushort,             MPI_UNSIGNED_SHORT)
PUT_VAR1_TYPE(int,       int,                MPI_INT)
PUT_VAR1_TYPE(uint,      uint,               MPI_UNSIGNED)
PUT_VAR1_TYPE(long,      long,               MPI_LONG)
PUT_VAR1_TYPE(float,     float,              MPI_FLOAT)
PUT_VAR1_TYPE(double,    double,             MPI_DOUBLE)
PUT_VAR1_TYPE(longlong,  long long,          MPI_LONG_LONG_INT)
PUT_VAR1_TYPE(ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG)
dnl PUT_VAR1_TYPE(string, char*,             MPI_CHAR)
dnl string is not yet supported

/*----< ncmpi_get_var1() >----------------------------------------------------*/
int
ncmpi_get_var1(int               ncid,
               int               varid,
               const MPI_Offset  start[],
               void             *buf,
               MPI_Offset        bufcount,
               MPI_Datatype      buftype)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;
    MPI_Offset *count;

    SANITY_CHECK(ncid, ncp, varp, READ_REQ, INDEP_IO, status)
    GET_ONE_COUNT(count)

    status = ncmpii_getput_vars(ncp, varp, start, count, NULL, buf,
                                bufcount, buftype, READ_REQ, INDEP_IO);
    if (varp->ndims > 0) NCI_Free(count);
    return status;
}

dnl
dnl GET_VAR1_TYPE(ncid, varid, start, ip)
dnl
define(`GET_VAR1_TYPE',dnl
`dnl
/*----< ncmpi_get_var1_$1() >-------------------------------------------------*/
int
ncmpi_get_var1_$1(int               ncid,
                  int               varid,
                  const MPI_Offset  start[],
                  $2               *ip)
{
    int         status;
    NC         *ncp;
    NC_var     *varp=NULL;
    MPI_Offset *count;

    SANITY_CHECK(ncid, ncp, varp, READ_REQ, INDEP_IO, status)
    GET_ONE_COUNT(count)

    /* get_var1 is a special case of get_vars */
    status = ncmpii_getput_vars(ncp, varp, start, count, NULL, ip,
                                1, $3, READ_REQ, INDEP_IO);
    if (varp->ndims > 0) NCI_Free(count);
    return status;
}
')dnl

GET_VAR1_TYPE(text,      char,               MPI_CHAR)
GET_VAR1_TYPE(schar,     schar,              MPI_BYTE)
GET_VAR1_TYPE(uchar,     uchar,              MPI_UNSIGNED_CHAR)
GET_VAR1_TYPE(short,     short,              MPI_SHORT)
GET_VAR1_TYPE(ushort,    ushort,             MPI_UNSIGNED_SHORT)
GET_VAR1_TYPE(int,       int,                MPI_INT)
GET_VAR1_TYPE(uint,      uint,               MPI_UNSIGNED)
GET_VAR1_TYPE(long,      long,               MPI_LONG)
GET_VAR1_TYPE(float,     float,              MPI_FLOAT)
GET_VAR1_TYPE(double,    double,             MPI_DOUBLE)
GET_VAR1_TYPE(longlong,  long long,          MPI_LONG_LONG_INT)
GET_VAR1_TYPE(ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG)
dnl GET_VAR1_TYPE(string, char*,             MPI_CHAR)
dnl string is not yet supported

dnl
dnl PUT_VARA(ncid, varid, start, count, buf, bufcount, buftype)
dnl
define(`PUT_VARA',dnl
`dnl
/*----< ncmpi_put_vara$1() >--------------------------------------------------*/
int
ncmpi_put_vara$1(int               ncid,
                 int               varid,
                 const MPI_Offset  start[],
                 const MPI_Offset  count[],
                 const void       *buf,
                 MPI_Offset        bufcount,
                 MPI_Datatype      buftype)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    SANITY_CHECK(ncid, ncp, varp, WRITE_REQ, $2, status)

    /* put_vara is a special case of put_vars */
    return ncmpii_getput_vars(ncp, varp, start, count, NULL, (void*)buf,
                              bufcount, buftype, WRITE_REQ, $2);
}
')dnl

dnl PnetCDF flexible APIs
PUT_VARA(    , INDEP_IO)
PUT_VARA(_all, COLL_IO)

dnl
dnl GET_VARA(ncid, varid, start, count, buf, bufcount, buftype)
dnl
define(`GET_VARA',dnl
`dnl
/*----< ncmpi_get_vara$1() >--------------------------------------------------*/
int
ncmpi_get_vara$1(int               ncid,
                 int               varid,
                 const MPI_Offset  start[],
                 const MPI_Offset  count[],
                 void             *buf,
                 MPI_Offset        bufcount,
                 MPI_Datatype      buftype)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    SANITY_CHECK(ncid, ncp, varp, READ_REQ, $2, status)

    /* get_vara is a special case of get_vars */
    return ncmpii_getput_vars(ncp, varp, start, count, NULL, buf,
                              bufcount, buftype, READ_REQ, $2);
}
')dnl

dnl PnetCDF flexible APIs
GET_VARA(    , INDEP_IO)
GET_VARA(_all, COLL_IO)

dnl
dnl PUT_VARA_TYPE(ncid, varid, start, count, op)
dnl
define(`PUT_VARA_TYPE',dnl
`dnl
/*----< ncmpi_put_vara_$1() >-------------------------------------------------*/
int
ncmpi_put_vara_$1(int               ncid,
                  int               varid,
                  const MPI_Offset  start[],
                  const MPI_Offset  count[],
                  const $2         *op)
{
    int         status;
    NC         *ncp;
    NC_var     *varp=NULL;
    MPI_Offset  nelems;

    SANITY_CHECK(ncid, ncp, varp, WRITE_REQ, $4, status)
    GET_NUM_ELEMENTS(nelems)

    /* put_vara is a special case of put_vars */
    return ncmpii_getput_vars(ncp, varp, start, count, NULL, (void*)op,
                              nelems, $3, WRITE_REQ, $4);
}
')dnl

PUT_VARA_TYPE(text,      char,               MPI_CHAR,               INDEP_IO)
PUT_VARA_TYPE(schar,     schar,              MPI_BYTE,               INDEP_IO)
PUT_VARA_TYPE(uchar,     uchar,              MPI_UNSIGNED_CHAR,      INDEP_IO)
PUT_VARA_TYPE(short,     short,              MPI_SHORT,              INDEP_IO)
PUT_VARA_TYPE(ushort,    ushort,             MPI_UNSIGNED_SHORT,     INDEP_IO)
PUT_VARA_TYPE(int,       int,                MPI_INT,                INDEP_IO)
PUT_VARA_TYPE(uint,      uint,               MPI_UNSIGNED,           INDEP_IO)
PUT_VARA_TYPE(long,      long,               MPI_LONG,               INDEP_IO)
PUT_VARA_TYPE(float,     float,              MPI_FLOAT,              INDEP_IO)
PUT_VARA_TYPE(double,    double,             MPI_DOUBLE,             INDEP_IO)
PUT_VARA_TYPE(longlong,  long long,          MPI_LONG_LONG_INT,      INDEP_IO)
PUT_VARA_TYPE(ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG, INDEP_IO)
dnl PUT_VARA_TYPE(string, char*,             MPI_CHAR,               INDEP_IO)
dnl string is not yet supported

PUT_VARA_TYPE(text_all,      char,               MPI_CHAR,              COLL_IO)
PUT_VARA_TYPE(schar_all,     schar,              MPI_BYTE,              COLL_IO)
PUT_VARA_TYPE(uchar_all,     uchar,              MPI_UNSIGNED_CHAR,     COLL_IO)
PUT_VARA_TYPE(short_all,     short,              MPI_SHORT,             COLL_IO)
PUT_VARA_TYPE(ushort_all,    ushort,             MPI_UNSIGNED_SHORT,    COLL_IO)
PUT_VARA_TYPE(int_all,       int,                MPI_INT,               COLL_IO)
PUT_VARA_TYPE(uint_all,      uint,               MPI_UNSIGNED,          COLL_IO)
PUT_VARA_TYPE(long_all,      long,               MPI_LONG,              COLL_IO)
PUT_VARA_TYPE(float_all,     float,              MPI_FLOAT,             COLL_IO)
PUT_VARA_TYPE(double_all,    double,             MPI_DOUBLE,            COLL_IO)
PUT_VARA_TYPE(longlong_all,  long long,          MPI_LONG_LONG_INT,     COLL_IO)
PUT_VARA_TYPE(ulonglong_all, unsigned long long, MPI_UNSIGNED_LONG_LONG,COLL_IO)
dnl PUT_VARA_TYPE(string_all, char*,             MPI_CHAR,              COLL_IO)
dnl string is not yet supported


dnl
dnl GET_VARA_TYPE(ncid, varid, start, count, ip)
dnl
define(`GET_VARA_TYPE',dnl
`dnl
/*----< ncmpi_get_vara_$1() >-------------------------------------------------*/
int
ncmpi_get_vara_$1(int               ncid,
                  int               varid,
                  const MPI_Offset  start[],
                  const MPI_Offset  count[],
                  $2               *ip)
{
    int         status;
    NC         *ncp;
    NC_var     *varp=NULL;
    MPI_Offset  nelems;

    SANITY_CHECK(ncid, ncp, varp, READ_REQ, $4, status)
    GET_NUM_ELEMENTS(nelems)

    /* get_vara is a special case of get_vars */
    return ncmpii_getput_vars(ncp, varp, start, count, NULL, ip,
                              nelems, $3, READ_REQ, $4);
}
')dnl

GET_VARA_TYPE(text,      char,               MPI_CHAR,               INDEP_IO)
GET_VARA_TYPE(schar,     schar,              MPI_BYTE,               INDEP_IO)
GET_VARA_TYPE(uchar,     uchar,              MPI_UNSIGNED_CHAR,      INDEP_IO)
GET_VARA_TYPE(short,     short,              MPI_SHORT,              INDEP_IO)
GET_VARA_TYPE(ushort,    ushort,             MPI_UNSIGNED_SHORT,     INDEP_IO)
GET_VARA_TYPE(int,       int,                MPI_INT,                INDEP_IO)
GET_VARA_TYPE(uint,      uint,               MPI_UNSIGNED,           INDEP_IO)
GET_VARA_TYPE(long,      long,               MPI_LONG,               INDEP_IO)
GET_VARA_TYPE(float,     float,              MPI_FLOAT,              INDEP_IO)
GET_VARA_TYPE(double,    double,             MPI_DOUBLE,             INDEP_IO)
GET_VARA_TYPE(longlong,  long long,          MPI_LONG_LONG_INT,      INDEP_IO)
GET_VARA_TYPE(ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG, INDEP_IO)
dnl GET_VARA_TYPE(string, char*,             MPI_CHAR,               INDEP_IO)
dnl string is not yet supported

GET_VARA_TYPE(text_all,      char,               MPI_CHAR,              COLL_IO)
GET_VARA_TYPE(schar_all,     schar,              MPI_BYTE,              COLL_IO)
GET_VARA_TYPE(uchar_all,     uchar,              MPI_UNSIGNED_CHAR,     COLL_IO)
GET_VARA_TYPE(short_all,     short,              MPI_SHORT,             COLL_IO)
GET_VARA_TYPE(ushort_all,    ushort,             MPI_UNSIGNED_SHORT,    COLL_IO)
GET_VARA_TYPE(int_all,       int,                MPI_INT,               COLL_IO)
GET_VARA_TYPE(uint_all,      uint,               MPI_UNSIGNED,          COLL_IO)
GET_VARA_TYPE(long_all,      long,               MPI_LONG,              COLL_IO)
GET_VARA_TYPE(float_all,     float,              MPI_FLOAT,             COLL_IO)
GET_VARA_TYPE(double_all,    double,             MPI_DOUBLE,            COLL_IO)
GET_VARA_TYPE(longlong_all,  long long,          MPI_LONG_LONG_INT,     COLL_IO)
GET_VARA_TYPE(ulonglong_all, unsigned long long, MPI_UNSIGNED_LONG_LONG,COLL_IO)
dnl GET_VARA_TYPE(string_all, char*,             MPI_CHAR,              COLL_IO)
dnl string is not yet supported

dnl
dnl PUT_VARS(ncid, varid, start, count, stride, buf, bufcount, buftype)
dnl
define(`PUT_VARS',dnl
`dnl
/*----< ncmpi_put_vars$1() >--------------------------------------------------*/
int
ncmpi_put_vars$1(int               ncid,
                 int               varid,
                 const MPI_Offset  start[],
                 const MPI_Offset  count[],
                 const MPI_Offset  stride[],
                 const void       *buf,
                 MPI_Offset        bufcount,
                 MPI_Datatype      buftype)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    SANITY_CHECK(ncid, ncp, varp, WRITE_REQ, $2, status)

    return ncmpii_getput_vars(ncp, varp, start, count, stride, (void*)buf,
                              bufcount, buftype, WRITE_REQ, $2);
}
')dnl

dnl PnetCDF flexible APIs
PUT_VARS(    , INDEP_IO)
PUT_VARS(_all, COLL_IO)

dnl
dnl GET_VARS(ncid, varid, start, count, stride, buf, bufcount, buftype)
dnl
define(`GET_VARS',dnl
`dnl
/*----< ncmpi_get_vars$1() >--------------------------------------------------*/
int
ncmpi_get_vars$1(int               ncid,
                 int               varid,
                 const MPI_Offset  start[],
                 const MPI_Offset  count[],
                 const MPI_Offset  stride[],
                 void             *buf,
                 MPI_Offset        bufcount,
                 MPI_Datatype      buftype)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    SANITY_CHECK(ncid, ncp, varp, READ_REQ, $2, status)

    return ncmpii_getput_vars(ncp, varp, start, count, stride, buf,
                              bufcount, buftype, READ_REQ, $2);
}
')dnl

dnl PnetCDF flexible APIs
GET_VARS(    , INDEP_IO)
GET_VARS(_all, COLL_IO)


dnl
dnl PUT_VARS_TYPE(ncid, varid, start, count, stride, op)
dnl
define(`PUT_VARS_TYPE',dnl
`dnl
/*----< ncmpi_put_vars_$1() >-------------------------------------------------*/
int
ncmpi_put_vars_$1(int               ncid,
                  int               varid,
                  const MPI_Offset  start[],
                  const MPI_Offset  count[],
                  const MPI_Offset  stride[],
                  const $2         *op)
{
    int         status;
    NC         *ncp;
    NC_var     *varp=NULL;
    MPI_Offset  nelems;

    SANITY_CHECK(ncid, ncp, varp, WRITE_REQ, $4, status)
    GET_NUM_ELEMENTS(nelems)

    return ncmpii_getput_vars(ncp, varp, start, count, stride, (void*)op,
                              nelems, $3, WRITE_REQ, $4);
}
')dnl

PUT_VARS_TYPE(text,      char,               MPI_CHAR,               INDEP_IO)
PUT_VARS_TYPE(schar,     schar,              MPI_BYTE,               INDEP_IO)
PUT_VARS_TYPE(uchar,     uchar,              MPI_UNSIGNED_CHAR,      INDEP_IO)
PUT_VARS_TYPE(short,     short,              MPI_SHORT,              INDEP_IO)
PUT_VARS_TYPE(ushort,    ushort,             MPI_UNSIGNED_SHORT,     INDEP_IO)
PUT_VARS_TYPE(int,       int,                MPI_INT,                INDEP_IO)
PUT_VARS_TYPE(uint,      uint,               MPI_UNSIGNED,           INDEP_IO)
PUT_VARS_TYPE(long,      long,               MPI_LONG,               INDEP_IO)
PUT_VARS_TYPE(float,     float,              MPI_FLOAT,              INDEP_IO)
PUT_VARS_TYPE(double,    double,             MPI_DOUBLE,             INDEP_IO)
PUT_VARS_TYPE(longlong,  long long,          MPI_LONG_LONG_INT,      INDEP_IO)
PUT_VARS_TYPE(ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG, INDEP_IO)
dnl PUT_VARS_TYPE(string, char*,             MPI_CHAR,               INDEP_IO)
dnl string is not yet supported

PUT_VARS_TYPE(text_all,      char,               MPI_CHAR,              COLL_IO)
PUT_VARS_TYPE(schar_all,     schar,              MPI_BYTE,              COLL_IO)
PUT_VARS_TYPE(uchar_all,     uchar,              MPI_UNSIGNED_CHAR,     COLL_IO)
PUT_VARS_TYPE(short_all,     short,              MPI_SHORT,             COLL_IO)
PUT_VARS_TYPE(ushort_all,    ushort,             MPI_UNSIGNED_SHORT,    COLL_IO)
PUT_VARS_TYPE(int_all,       int,                MPI_INT,               COLL_IO)
PUT_VARS_TYPE(uint_all,      uint,               MPI_UNSIGNED,          COLL_IO)
PUT_VARS_TYPE(long_all,      long,               MPI_LONG,              COLL_IO)
PUT_VARS_TYPE(float_all,     float,              MPI_FLOAT,             COLL_IO)
PUT_VARS_TYPE(double_all,    double,             MPI_DOUBLE,            COLL_IO)
PUT_VARS_TYPE(longlong_all,  long long,          MPI_LONG_LONG_INT,     COLL_IO)
PUT_VARS_TYPE(ulonglong_all, unsigned long long, MPI_UNSIGNED_LONG_LONG,COLL_IO)
dnl PUT_VARS_TYPE(string_all, char*,             MPI_CHAR,              COLL_IO)
dnl string is not yet supported


dnl
dnl GET_VARS_TYPE(ncid, varid, start, count, stride, ip)
dnl
define(`GET_VARS_TYPE',dnl
`dnl
/*----< ncmpi_get_vars_$1() >-------------------------------------------------*/
int
ncmpi_get_vars_$1(int               ncid,
                  int               varid,
                  const MPI_Offset  start[],
                  const MPI_Offset  count[],
                  const MPI_Offset  stride[],
                  $2              *ip)
{
    int         status;
    NC         *ncp;
    NC_var     *varp=NULL;
    MPI_Offset  nelems;

    SANITY_CHECK(ncid, ncp, varp, READ_REQ, $4, status)

    GET_NUM_ELEMENTS(nelems)

    return ncmpii_getput_vars(ncp, varp, start, count, stride, ip,
                              nelems, $3, READ_REQ, $4);
}
')dnl

GET_VARS_TYPE(text,      char,               MPI_CHAR,               INDEP_IO)
GET_VARS_TYPE(schar,     schar,              MPI_BYTE,               INDEP_IO)
GET_VARS_TYPE(uchar,     uchar,              MPI_UNSIGNED_CHAR,      INDEP_IO)
GET_VARS_TYPE(short,     short,              MPI_SHORT,              INDEP_IO)
GET_VARS_TYPE(ushort,    ushort,             MPI_UNSIGNED_SHORT,     INDEP_IO)
GET_VARS_TYPE(int,       int,                MPI_INT,                INDEP_IO)
GET_VARS_TYPE(uint,      uint,               MPI_UNSIGNED,           INDEP_IO)
GET_VARS_TYPE(long,      long,               MPI_LONG,               INDEP_IO)
GET_VARS_TYPE(float,     float,              MPI_FLOAT,              INDEP_IO)
GET_VARS_TYPE(double,    double,             MPI_DOUBLE,             INDEP_IO)
GET_VARS_TYPE(longlong,  long long,          MPI_LONG_LONG_INT,      INDEP_IO)
GET_VARS_TYPE(ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG, INDEP_IO)
dnl GET_VARS_TYPE(string, char*,             MPI_CHAR,               INDEP_IO)
dnl string is not yet supported

GET_VARS_TYPE(text_all,      char,               MPI_CHAR,              COLL_IO)
GET_VARS_TYPE(schar_all,     schar,              MPI_BYTE,              COLL_IO)
GET_VARS_TYPE(uchar_all,     uchar,              MPI_UNSIGNED_CHAR,     COLL_IO)
GET_VARS_TYPE(short_all,     short,              MPI_SHORT,             COLL_IO)
GET_VARS_TYPE(ushort_all,    ushort,             MPI_UNSIGNED_SHORT,    COLL_IO)
GET_VARS_TYPE(int_all,       int,                MPI_INT,               COLL_IO)
GET_VARS_TYPE(uint_all,      uint,               MPI_UNSIGNED,          COLL_IO)
GET_VARS_TYPE(long_all,      long,               MPI_LONG,              COLL_IO)
GET_VARS_TYPE(float_all,     float,              MPI_FLOAT,             COLL_IO)
GET_VARS_TYPE(double_all,    double,             MPI_DOUBLE,            COLL_IO)
GET_VARS_TYPE(longlong_all,  long long,          MPI_LONG_LONG_INT,     COLL_IO)
GET_VARS_TYPE(ulonglong_all, unsigned long long, MPI_UNSIGNED_LONG_LONG,COLL_IO)
dnl GET_VARS_TYPE(string_all, char*,             MPI_CHAR,              COLL_IO)
dnl string is not yet supported



/* for write case, buf needs to swapped back if swapped previously */
#define FINAL_CLEAN_UP {                                                       \
    if (is_buf_swapped) /* byte-swap back to buf's original contents */        \
        ncmpii_in_swapn(buf, fnelems, ncmpix_len_nctype(varp->type));          \
                                                                               \
    if (xbuf != NULL && xbuf != cbuf) NCI_Free(xbuf);                          \
    if (cbuf != NULL && cbuf !=  buf) NCI_Free(cbuf);                          \
}

/* buffer layers:       
        
   User Level              buf     (user defined buffer of MPI_Datatype)
   MPI Datatype Level      cbuf    (contiguous buffer of ptype)
   NetCDF XDR Level        xbuf    (XDR I/O buffer)

   The principle of buffer management is:

   for put_vars:
     1. pack buf to cbuf based on buftype
     2. type convert and byte swap cbuf to xbuf
     3. write from xbuf
     4. byte swap the buf back to its original, if it is swapped
     5. free up temp buffers, cbuf and xbuf if they were allocated separately

   for get_vars:
     1. allocate cbuf
     2. allocate xbuf
     3. read to xbuf
     4. type convert and byte swap xbuf to cbuf
     5. unpack cbuf to buf based on buftype
     6. free up temp buffers, cbuf and xbuf if they were allocated separately
*/

/*----< ncmpii_getput_vars() >------------------------------------------------*/
int
ncmpii_getput_vars(NC               *ncp,
                   NC_var           *varp,
                   const MPI_Offset  start[],
                   const MPI_Offset  count[],
                   const MPI_Offset  stride[],
                   void             *buf,
                   MPI_Offset        bufcount,
                   MPI_Datatype      buftype,  /* data type of the bufer */
                   int               rw_flag,
                   int               io_method)
{
    void *xbuf=NULL, *cbuf=NULL;
    int isderived, el_size, mpireturn;
    int warning, err, status; /* err is for API abort and status is not */
    int buftype_is_contig, need_swap=0, need_convert=0, is_buf_swapped=0;
    MPI_Offset fnelems=1, bnelems, nbytes, offset=0;
    MPI_Status mpistatus;
    MPI_Datatype ptype, filetype=MPI_BYTE;
    MPI_File fh;

    /* "API error" will abort this API call, but not the entire program */
    err = status = warning = NC_NOERR;

#ifdef ENABLE_SUBFILING
    /* call a separate routine if variable is stored in subfiles */
    if (varp->num_subfiles > 1) {
#ifdef SUBFILE_DEBUG
	printf("var(%s) is stored in subfiles\n", varp->name->cp);
#endif
	status = ncmpii_subfile_getput_vars(ncp, varp, start, count, stride,
					    buf, bufcount, buftype,
					    rw_flag, io_method);
	return status;
    }
#endif

    if (varp->ndims > 0) {
        assert(start != NULL);
        assert(count != NULL);
    }

    if (io_method == COLL_IO)
        fh = ncp->nciop->collective_fh;
    else
        fh = ncp->nciop->independent_fh;

    /* Check if buftype is contiguous (for flexible APIs). If no, we must pack
     * it into a contiguous buffer, named cbuf
     * find the ptype (primitive MPI data type) from buftype
     * el_size is the element size of ptype
     * bnelems is the total number of ptype elements in the I/O buffer, buf
     * fnelems is the number of nc variable elements in nc_type
     * nbytes is the amount of read/write in bytes
     */
    err = ncmpii_dtype_decode(buftype, &ptype, &el_size, &bnelems,
                              &isderived, &buftype_is_contig);
    /* bnelems now is the number of ptype in a buftype */
    if (err != NC_NOERR) goto err_check;

    err = NCMPII_ECHAR(varp->type, ptype);
    if (err != NC_NOERR) goto err_check;   

    CHECK_NELEMS(varp, fnelems, count, bnelems, bufcount, nbytes, err)
    if (nbytes != (int)nbytes) {
        err = NC_EINTOVERFLOW;
        if (io_method == INDEP_IO) return err;
        goto err_check;
    }
    /* bnelems now is the number of ptype in the whole buf */
    /* warning is set in CHECK_NELEMS() */

    if (bnelems == 0) { /* if this process has nothing to read/write */
        if (io_method == INDEP_IO)
            return NCcoordck(ncp, varp, start, rw_flag);
#ifdef ZERO_COUNT_IGNORE_OTHER_ERRORS
        else
        /* for collective I/O, even bnelems == 0, must go on to participate
           the collective calls: MPI_File_set_view and collective read/write */
            goto err_check;
#endif
    }

    if (!buftype_is_contig) { /* buf is noncontiguous in memory */
        if (rw_flag == WRITE_REQ) {
            /* pack buf into cbuf, a contiguous buffer */
            cbuf = (void*) NCI_Malloc(bnelems * el_size);
            err = ncmpii_data_repack((void*)buf, bufcount, buftype,
                                     cbuf, bnelems, ptype);
            if (err != NC_NOERR) /* API error */
                goto err_check;
        }
    } else {
        cbuf = (void*) buf;
    }

    /* Check if we need type convert and byte swap cbuf (into xbuf) */
    need_swap = ncmpii_need_swap(varp->type, ptype);
    need_convert = ncmpii_need_convert(varp->type, ptype);
    if (need_convert) {
        /* allocate new buffer for data type conversion */
        xbuf = NCI_Malloc(nbytes);

        if (rw_flag == WRITE_REQ) {
            /* type convert and byte-swap cbuf to xbuf */
            DATATYPE_PUT_CONVERT(varp->type, xbuf, cbuf, bnelems, ptype, err)
            /* retain the first error status */
            if (status == NC_NOERR) status = err;
        }
    } else if (need_swap) {
        if (rw_flag == WRITE_REQ) { /* perform array in-place byte swap */
            ncmpii_in_swapn(cbuf, fnelems, ncmpix_len_nctype(varp->type));
            is_buf_swapped = (cbuf == buf) ? 1 : 0;
            /* is_buf_swapped indicates if the contents of the original user
             * buffer, buf, have been changed, i.e. byte swapped. */
        }
        xbuf = cbuf;
    } else {
        /* else, no type conversion or byte swap */
        xbuf = cbuf;
    }
    /* xbuf is the buffer whose data has been converted into the external
     * data type, ready to be written to the netCDF file. Similar for read,
     * after read from file, the contents of xbuf are in external type
     */

    /* if record variables are too big (so big that we cannot store the
     * stride between records in an MPI_Aint, for example) then we will
     * have to process this one record at a time.  
     */

    /* check if the request is contiguous in file */
    if (stride == NULL && ncmpii_is_request_contiguous(varp, start, count)) {
        err = NCedgeck(ncp, varp, start, count);

        if (err != NC_NOERR ||
            (rw_flag == READ_REQ && IS_RECVAR(varp) &&
             start[0] + count[0] > NC_get_numrecs(ncp))) { /* API error */
            err = NCcoordck(ncp, varp, start, rw_flag);
            if (err == NC_NOERR) err = NC_EEDGE;
            goto err_check;
        }

        /* this is a contiguous file access, no need to set filetype */
        err = ncmpii_get_offset(ncp, varp, start, NULL, NULL, rw_flag, &offset);
        /* if start[] is out of defined size, then this will return
         * NC_EINVALCOORDS error */
        if (err != NC_NOERR) /* API error */
            goto err_check;
    }
    else {
        /* this request is non-contiguous in file, create the mpi file type */
        int blocklen;
        err = ncmpii_vars_create_filetype(ncp, varp, start, count, stride,
                                          rw_flag, &blocklen, &offset,
                                          &filetype);
        if (err != NC_NOERR) /* API error */
            goto err_check;
    }

err_check:
    /* check API error from any proc before going into a collective call.
     * optimization: to avoid MPI_Allreduce to check parameters at
     * every call, we assume caller does the right thing most of the
     * time.  If caller passed in bad parameters, we'll still conduct a
     * zero-byte operation (everyone has to participate in the
     * collective I/O call) but return error */
    if (err != NC_NOERR) {
        /* release allocated resources */
        if (filetype != MPI_BYTE)
            MPI_Type_free(&filetype);
        filetype = MPI_BYTE;

        FINAL_CLEAN_UP  /* swap back put buffer and free temp buffers */
        if (io_method == COLL_IO)
            ncmpii_getput_zero_req(ncp, rw_flag, IS_RECVAR(varp));

        return err;
    }

    /* MPI_File_set_view is a collective if (io_method == COLL_IO) */
    mpireturn = MPI_File_set_view(fh, offset, MPI_BYTE, filetype,
                                  "native", MPI_INFO_NULL);
    if (mpireturn != MPI_SUCCESS) {
        ncmpii_handle_error(mpireturn, "MPI_File_set_view");
        /* return the first encountered error if there is any */
        if (status == NC_NOERR) status = NC_EFILE;
    }

    if (filetype != MPI_BYTE)
        MPI_Type_free(&filetype);

    if (rw_flag == WRITE_REQ) {
        if (io_method == COLL_IO) {
            mpireturn = MPI_File_write_all(fh, xbuf, nbytes, MPI_BYTE, &mpistatus);
            if (mpireturn != MPI_SUCCESS) {
                ncmpii_handle_error(mpireturn, "MPI_File_write_all");
                /* return the first encountered error if there is any */
                if (status == NC_NOERR) status = NC_EWRITE;
            }
        }
        else { /* io_method == INDEP_IO */
            mpireturn = MPI_File_write(fh, xbuf, nbytes, MPI_BYTE, &mpistatus);
            if (mpireturn != MPI_SUCCESS) {
                ncmpii_handle_error(mpireturn, "MPI_File_write");
                /* return the first encountered error if there is any */
                if (status == NC_NOERR) status = NC_EWRITE;
            }
        }
        int put_size;
        MPI_Get_count(&mpistatus, MPI_BYTE, &put_size);
        ncp->nciop->put_size += put_size;
    }
    else {  /* rw_flag == READ_REQ */
        if (io_method == COLL_IO) {
            mpireturn = MPI_File_read_all(fh, xbuf, nbytes, MPI_BYTE, &mpistatus);
            if (mpireturn != MPI_SUCCESS) {
                ncmpii_handle_error(mpireturn, "MPI_File_read_all");
                /* return the first encountered error if there is any */
                if (status == NC_NOERR) status = NC_EREAD;
            }
        }
        else { /* io_method == INDEP_IO */
            mpireturn = MPI_File_read(fh, xbuf, nbytes, MPI_BYTE, &mpistatus);
            if (mpireturn != MPI_SUCCESS) {
                ncmpii_handle_error(mpireturn, "MPI_File_read");
                /* return the first encountered error if there is any */
                if (status == NC_NOERR) status = NC_EREAD;
            }
        }
        int get_size;
        MPI_Get_count(&mpistatus, MPI_BYTE, &get_size);
        ncp->nciop->get_size += get_size;
    }

    /* reset the file view so the entire file is visible again */
    MPI_File_set_view(fh, 0, MPI_BYTE, MPI_BYTE, "native", MPI_INFO_NULL);

    if (rw_flag == READ_REQ) {
        if (!buftype_is_contig) /* buf is noncontiguous in memory */
            /* allocate cbuf, so xbuf can type-convert/byte-swap to cbuf
               and later cbuf can be unpacked to buf using buftype */
            cbuf = (void*) NCI_Malloc(bnelems * el_size);
        else
            cbuf = (void*) buf;

        if (need_convert) {
            /* type conversion + swap from xbuf to cbuf */
            DATATYPE_GET_CONVERT(varp->type, xbuf, cbuf, bnelems, ptype, err)
            /* retain the first error status */
            if (status == NC_NOERR) status = err;
        } else if (need_swap) {
            /* perform array in-place byte swap from xbuf to cbuf */
            ncmpii_in_swapn(cbuf, fnelems, ncmpix_len_nctype(varp->type));
        }

        if (!buftype_is_contig) {
            /* unpack cbuf to buf using buftype */
            err = ncmpii_data_repack(cbuf, bnelems, ptype,
                                     (void*)buf, bufcount, buftype);
            if (err != NC_NOERR) {
                FINAL_CLEAN_UP  /* free temp buffers */
                return err;
            }
        }
    }
    else { /* WRITE_REQ */
        if (IS_RECVAR(varp)) {
            /* update header's number of records in memory */
            MPI_Offset new_numrecs;

            if (status == NC_NOERR) {
                if (stride == NULL)
                    new_numrecs = start[0] + count[0];
                else
                    new_numrecs = start[0] + (count[0] - 1) * stride[0] + 1;
            }
            else
                new_numrecs = ncp->numrecs;

            if (io_method == INDEP_IO) {
                /* FIXME: if we update numrecs to file now, race condition
                   can happen. Hence, we delay the update till file close or
                   exit independent data mode. Note numrecs in memory may be
                   inconsistent and obsolete till then.
                 */
                if (ncp->numrecs < new_numrecs) {
                    ncp->numrecs = new_numrecs;
                    set_NC_ndirty(ncp);
                }
            }
            else /* COLL_IO */
                ncmpii_sync_numrecs(ncp, new_numrecs);
        }
    }

    FINAL_CLEAN_UP  /* swap back the put buffer and free temp buffers */

    return ((warning != NC_NOERR) ? warning : status);
}

/* buffer layers:       
        
   User Level              buf     (user defined buffer of MPI_Datatype)
   MPI Datatype Level      cbuf    (contiguous buffer of ptype)
   NetCDF XDR Level        xbuf    (XDR I/O buffer)
*/

/* varm: there maybe two layer of memory layout (remapping):
         one is specified by MPI derived datatype,
         the other is specified by imap[],
         it's encouraged to use only one option of them,
         though using both of them are supported.

   user buffer:                         |--------------------------|

   mpi derived datatype view:           |------|  |------|  |------|
                
   logic (contig) memory datastream:       |------|------|------|

   imap view:                              |--| |--|    |--| |--|

   contig I/O datastream (internal represent): |--|--|--|--|

   These two layers of memory layout will both be represented in MPI 
   derived datatype, and if double layers of memory layout is used, 
   we need to elimilate the upper one passed in MPI_Datatype parameter
   from the user, by repacking it to logic contig memory datastream view.

   for put_varm:
     1. pack buf to lbuf based on buftype
     2. create imap_type based on imap
     3. pack lbuf to cbuf based on imap_type
     4. type convert and byte swap cbuf to xbuf
     5. write from xbuf
     6. byte swap the buf, if it is swapped
     7. free up temp buffers

   for get_varm:
     1. allocate lbuf
     2. create imap_type based on imap
     3. allocate cbuf
     4. allocate xbuf
     5. read to xbuf
     6. type convert and byte swap xbuf to cbuf
     7. unpack cbuf to lbuf based on imap_type
     8. unpack lbuf to buf based on buftype
*/

dnl
dnl PUT_VARM(ncid, varid, start, count, stride, imap, buf, bufcount, buftype)
dnl
define(`PUT_VARM',dnl
`dnl
/*----< ncmpi_put_varm$1() >--------------------------------------------------*/
int
ncmpi_put_varm$1(int               ncid,
                 int               varid,
                 const MPI_Offset  start[],
                 const MPI_Offset  count[],
                 const MPI_Offset  stride[],
                 const MPI_Offset  imap[],
                 const void       *buf,
                 MPI_Offset        bufcount,
                 MPI_Datatype      buftype)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    SANITY_CHECK(ncid, ncp, varp, WRITE_REQ, $2, status)

    return ncmpii_getput_varm(ncp, varp, start, count, stride, imap,
                              (void*)buf, bufcount, buftype, WRITE_REQ, $2);
}
')dnl

dnl PnetCDF flexible APIs
PUT_VARM(    , INDEP_IO)
PUT_VARM(_all, COLL_IO)

dnl
dnl GET_VARM(ncid, varid, start, count, stride, imap, buf, bufcount, buftype)
dnl
define(`GET_VARM',dnl
`dnl
/*----< ncmpi_get_varm$1() >--------------------------------------------------*/
int
ncmpi_get_varm$1(int               ncid,
                 int               varid,
                 const MPI_Offset  start[],
                 const MPI_Offset  count[],
                 const MPI_Offset  stride[],
                 const MPI_Offset  imap[],
                 void             *buf,
                 MPI_Offset        bufcount,
                 MPI_Datatype      buftype)
{
    int     status;
    NC     *ncp;
    NC_var *varp=NULL;

    SANITY_CHECK(ncid, ncp, varp, READ_REQ, $2, status)

    return ncmpii_getput_varm(ncp, varp, start, count, stride, imap,
                              buf, bufcount, buftype, READ_REQ, $2);
}
')dnl

dnl PnetCDF flexible APIs
GET_VARM(    , INDEP_IO)
GET_VARM(_all, COLL_IO)

dnl
dnl PUT_VARM_TYPE(ncid, varid, start, count, stride, imap, op)
dnl
define(`PUT_VARM_TYPE',dnl
`dnl
/*----< ncmpi_put_varm_$1() >-------------------------------------------------*/
int
ncmpi_put_varm_$1(int               ncid,
                  int               varid,
                  const MPI_Offset  start[],
                  const MPI_Offset  count[],
                  const MPI_Offset  stride[],
                  const MPI_Offset  imap[],
                  const $2         *op)
{
    int         status;
    NC         *ncp;
    NC_var     *varp=NULL;
    MPI_Offset  nelems;

    SANITY_CHECK(ncid, ncp, varp, WRITE_REQ, $4, status)
    GET_NUM_ELEMENTS(nelems)

    return ncmpii_getput_varm(ncp, varp, start, count, stride, imap,
                              (void*)op, nelems, $3, WRITE_REQ, $4);
}
')dnl

PUT_VARM_TYPE(text,      char,               MPI_CHAR,               INDEP_IO)
PUT_VARM_TYPE(schar,     schar,              MPI_BYTE,               INDEP_IO)
PUT_VARM_TYPE(uchar,     uchar,              MPI_UNSIGNED_CHAR,      INDEP_IO)
PUT_VARM_TYPE(short,     short,              MPI_SHORT,              INDEP_IO)
PUT_VARM_TYPE(ushort,    ushort,             MPI_UNSIGNED_SHORT,     INDEP_IO)
PUT_VARM_TYPE(int,       int,                MPI_INT,                INDEP_IO)
PUT_VARM_TYPE(uint,      uint,               MPI_UNSIGNED,           INDEP_IO)
PUT_VARM_TYPE(long,      long,               MPI_LONG,               INDEP_IO)
PUT_VARM_TYPE(float,     float,              MPI_FLOAT,              INDEP_IO)
PUT_VARM_TYPE(double,    double,             MPI_DOUBLE,             INDEP_IO)
PUT_VARM_TYPE(longlong,  long long,          MPI_LONG_LONG_INT,      INDEP_IO)
PUT_VARM_TYPE(ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG, INDEP_IO)
dnl PUT_VARM_TYPE(string, char*,             MPI_CHAR,               INDEP_IO)
dnl string is not yet supported

PUT_VARM_TYPE(text_all,      char,               MPI_CHAR,              COLL_IO)
PUT_VARM_TYPE(schar_all,     schar,              MPI_BYTE,              COLL_IO)
PUT_VARM_TYPE(uchar_all,     uchar,              MPI_UNSIGNED_CHAR,     COLL_IO)
PUT_VARM_TYPE(short_all,     short,              MPI_SHORT,             COLL_IO)
PUT_VARM_TYPE(ushort_all,    ushort,             MPI_UNSIGNED_SHORT,    COLL_IO)
PUT_VARM_TYPE(int_all,       int,                MPI_INT,               COLL_IO)
PUT_VARM_TYPE(uint_all,      uint,               MPI_UNSIGNED,          COLL_IO)
PUT_VARM_TYPE(long_all,      long,               MPI_LONG,              COLL_IO)
PUT_VARM_TYPE(float_all,     float,              MPI_FLOAT,             COLL_IO)
PUT_VARM_TYPE(double_all,    double,             MPI_DOUBLE,            COLL_IO)
PUT_VARM_TYPE(longlong_all,  long long,          MPI_LONG_LONG_INT,     COLL_IO)
PUT_VARM_TYPE(ulonglong_all, unsigned long long, MPI_UNSIGNED_LONG_LONG,COLL_IO)
dnl PUT_VARM_TYPE(string_all, char*,             MPI_CHAR,              COLL_IO)
dnl string is not yet supported


dnl
dnl GET_VARM_TYPE(ncid, varid, start, count, stride, imap, ip)
dnl
define(`GET_VARM_TYPE',dnl
`dnl
/*----< ncmpi_get_varm_$1() >-------------------------------------------------*/
int
ncmpi_get_varm_$1(int               ncid,
                  int               varid,
                  const MPI_Offset  start[],
                  const MPI_Offset  count[],
                  const MPI_Offset  stride[],
                  const MPI_Offset  imap[],
                  $2               *ip)
{
    int         status;
    NC         *ncp;
    NC_var     *varp=NULL;
    MPI_Offset  nelems;

    SANITY_CHECK(ncid, ncp, varp, READ_REQ, $4, status)
    GET_NUM_ELEMENTS(nelems)

    return ncmpii_getput_varm(ncp, varp, start, count, stride, imap,
                              ip, nelems, $3, READ_REQ, $4);
}
')dnl

GET_VARM_TYPE(text,      char,               MPI_CHAR,               INDEP_IO)
GET_VARM_TYPE(schar,     schar,              MPI_BYTE,               INDEP_IO)
GET_VARM_TYPE(uchar,     uchar,              MPI_UNSIGNED_CHAR,      INDEP_IO)
GET_VARM_TYPE(short,     short,              MPI_SHORT,              INDEP_IO)
GET_VARM_TYPE(ushort,    ushort,             MPI_UNSIGNED_SHORT,     INDEP_IO)
GET_VARM_TYPE(int,       int,                MPI_INT,                INDEP_IO)
GET_VARM_TYPE(uint,      uint,               MPI_UNSIGNED,           INDEP_IO)
GET_VARM_TYPE(long,      long,               MPI_LONG,               INDEP_IO)
GET_VARM_TYPE(float,     float,              MPI_FLOAT,              INDEP_IO)
GET_VARM_TYPE(double,    double,             MPI_DOUBLE,             INDEP_IO)
GET_VARM_TYPE(longlong,  long long,          MPI_LONG_LONG_INT,      INDEP_IO)
GET_VARM_TYPE(ulonglong, unsigned long long, MPI_UNSIGNED_LONG_LONG, INDEP_IO)
dnl GET_VARM_TYPE(string, char*,             MPI_CHAR,               INDEP_IO)
dnl string is not yet supported

GET_VARM_TYPE(text_all,      char,               MPI_CHAR,              COLL_IO)
GET_VARM_TYPE(schar_all,     schar,              MPI_BYTE,              COLL_IO)
GET_VARM_TYPE(uchar_all,     uchar,              MPI_UNSIGNED_CHAR,     COLL_IO)
GET_VARM_TYPE(short_all,     short,              MPI_SHORT,             COLL_IO)
GET_VARM_TYPE(ushort_all,    ushort,             MPI_UNSIGNED_SHORT,    COLL_IO)
GET_VARM_TYPE(int_all,       int,                MPI_INT,               COLL_IO)
GET_VARM_TYPE(uint_all,      uint,               MPI_UNSIGNED,          COLL_IO)
GET_VARM_TYPE(long_all,      long,               MPI_LONG,              COLL_IO)
GET_VARM_TYPE(float_all,     float,              MPI_FLOAT,             COLL_IO)
GET_VARM_TYPE(double_all,    double,             MPI_DOUBLE,            COLL_IO)
GET_VARM_TYPE(longlong_all,  long long,          MPI_LONG_LONG_INT,     COLL_IO)
GET_VARM_TYPE(ulonglong_all, unsigned long long, MPI_UNSIGNED_LONG_LONG,COLL_IO)
dnl GET_VARM_TYPE(string_all, char*,             MPI_CHAR,              COLL_IO)
dnl string is not yet supported

/*----< ncmpii_getput_varm() >------------------------------------------------*/
int
ncmpii_getput_varm(NC               *ncp,
                   NC_var           *varp,
                   const MPI_Offset  start[],
                   const MPI_Offset  count[],
                   const MPI_Offset  stride[],
                   const MPI_Offset  imap[],
                   void             *buf,
                   MPI_Offset        bufcount,
                   MPI_Datatype      buftype,
                   int               rw_flag,    /* WRITE_REQ or READ_REQ */
                   int               io_method)  /* COLL_IO or INDEP_IO */
{
    void *lbuf=NULL, *cbuf=NULL;
    int err, status, warning; /* err is for API abort and status is not */
    int dim, imap_contig_blocklen, el_size, buftype_is_contig, isderived;
    MPI_Offset lnelems, cnelems;
    MPI_Datatype ptype, tmptype, imaptype;

    /* "API error" will abort this API call, but not the entire program */
    err = status = warning = NC_NOERR;
    imaptype = MPI_DATATYPE_NULL;

    if (imap == NULL || varp->ndims == 0) {
        /* when imap == NULL, no mapping, same as vars.
           when varp->ndims == 0, reduced to scalar var, only one value
           at one fixed place */
        return ncmpii_getput_vars(ncp, varp, start, count, stride, buf,
                                  bufcount, buftype, rw_flag, io_method);
    }

    /* test each dim's contiguity in imap[] until the 1st non-contiguous dim
       is reached */
    imap_contig_blocklen = 1;
    dim = varp->ndims;
    while ( --dim >= 0 && imap_contig_blocklen == imap[dim] ) {
        if (count[dim] < 0) { /* API error */
            err = NC_ENEGATIVECNT;
            goto err_check;
        }
        imap_contig_blocklen *= count[dim];
    }

    if (dim == -1) /* imap is a contiguous layout */
        return ncmpii_getput_vars(ncp, varp, start, count, stride, buf,
                                  bufcount, buftype, rw_flag, io_method);

    /* else imap gives non-contiguous layout, we will do pack/unpack I/O
       buffer based on imap[], but first must check if buftype is contiguous
       in case for flexible APIs
     */

    /* find the ptype (primitive MPI data type) from buftype
     * el_size is the element size of ptype
     * lnelems is the number of ptype elements in the buftype
     */
    err = ncmpii_dtype_decode(buftype, &ptype, &el_size, &lnelems,
                              &isderived, &buftype_is_contig);
    if (err != NC_NOERR)  /* API error */
        goto err_check;

    if (!buftype_is_contig) {
        /* buftype is not a contiguous of ptypes: pack buf to lbuf, a
           contiguous buffer, using buftype */
        lnelems *= bufcount;
        if (rw_flag == WRITE_REQ) { /* only write needs this packing */
            lbuf = NCI_Malloc(lnelems*el_size);
            status = ncmpii_data_repack((void*)buf, bufcount, buftype,
                                        lbuf, lnelems, ptype);
            if (status != NC_NOERR) { /* API error */
                err = ((warning != NC_NOERR) ? warning : status);
                goto err_check;
            }
        }
    } else {
        lbuf = buf;
    }

    /* construct an MPI datatype based on imap[], and use it to pack lbuf
       to cbuf, another contiguous buffer */
    MPI_Type_vector(count[dim], imap_contig_blocklen, imap[dim],
                    ptype, &imaptype);
    MPI_Type_commit(&imaptype);
    cnelems = imap_contig_blocklen*count[dim];
    for (dim--; dim>=0; dim--) {
        if (count[dim] < 0) { /* API error */
            err = ((warning != NC_NOERR) ? warning : NC_ENEGATIVECNT);
            goto err_check;
        }
#if (MPI_VERSION < 2)
        MPI_Type_hvector(count[dim], 1, imap[dim]*el_size, imaptype, &tmptype);
#else
        MPI_Type_create_hvector(count[dim], 1, (MPI_Aint)imap[dim]*el_size,
                                imaptype, &tmptype);
#endif
        MPI_Type_free(&imaptype);
        MPI_Type_commit(&tmptype);
        imaptype = tmptype;
        cnelems *= count[dim];
    }

    /* cbuf cannot be lbuf, as imap[] gives a non-contigous layout */
    cbuf = (void*) NCI_Malloc(cnelems*el_size);

    if (rw_flag == WRITE_REQ) {
        /* layout lbuf to cbuf based on imap */
        err = ncmpii_data_repack(lbuf, 1, imaptype, cbuf, cnelems, ptype);
        if (err != NC_NOERR) goto err_check;
        /* For write case, till now all request data has been packed into
           cbuf, so simply call ncmpii_getput_vars() to fulfill the write.
           lbuf is not needed anymore */
        if (lbuf != NULL && lbuf != buf) NCI_Free(lbuf);
        lbuf = NULL;
    }

err_check:
    /* check API error from any proc before going into a collective call.
     * optimization: to avoid MPI_Allreduce to check parameters at
     * every call, we assume caller does the right thing most of the
     * time.  If caller passed in bad parameters, we'll still conduct a
     * zero-byte operation (everyone has to participate in the
     * collective I/O call) but return error */
    if (err != NC_NOERR) {  /* handle the error */
        if (io_method == COLL_IO) {
            MPI_Offset *zeros;
            zeros = (MPI_Offset *) NCI_Calloc(varp->ndims, sizeof(MPI_Offset));
            ncmpii_getput_vars(ncp, varp, zeros, zeros, NULL, buf,
                               0, MPI_BYTE, rw_flag, io_method);
            NCI_Free(zeros);
        }
        if (lbuf != NULL && lbuf != buf) NCI_Free(lbuf);
        if (cbuf != NULL)                NCI_Free(cbuf);
        if (imaptype != MPI_DATATYPE_NULL)
            MPI_Type_free(&imaptype);
        return err;
    }

    /* now, we can use cbuf and cnelems to call getput_vars */
    status = ncmpii_getput_vars(ncp, varp, start, count, stride, cbuf,
                                cnelems, ptype, rw_flag, io_method);
    if (status != NC_NOERR)
        goto err_check2;

    if (rw_flag == READ_REQ) {
        /* now, cbuf contains the data read from file and they are all
           type converted and byte-swapped */

        if (!buftype_is_contig)
            /* buftype is not contiguous: unpack cbuf to lbuf, a contiguous
               buffer, using imap, so later lbuf can be unpacked to buf */
            lbuf = NCI_Malloc(lnelems*el_size);
        else
            lbuf = buf;

        /* layout cbuf to lbuf based on imap */
        status = ncmpii_data_repack(cbuf, cnelems, ptype, lbuf, 1, imaptype);
        if (status != NC_NOERR)
            goto err_check2;

        /* layout lbuf to buf based on buftype */
        if (!buftype_is_contig) {
            status = ncmpii_data_repack(lbuf, lnelems, ptype,
                                        (void *)buf, bufcount, buftype);
            /* if (status != NC_NOERR) goto err_check2; */
        }
    }

err_check2:
    if (lbuf != NULL && lbuf != buf) NCI_Free(lbuf);
    if (cbuf != NULL)                NCI_Free(cbuf);

    if (imaptype != MPI_DATATYPE_NULL)
        MPI_Type_free(&imaptype);

    return ((warning != NC_NOERR) ? warning : status);
}
